<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Antlr4.Runtime.net35</name>
    </assembly>
    <members>
        <member name="T:Antlr4.Runtime.AntlrFileStream">
            <summary>
            This is an
            <see cref="T:Antlr4.Runtime.AntlrInputStream"/>
            that is loaded from a file all at once
            when you construct the object.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.AntlrInputStream">
            <summary>
            Vacuum all input from a
            <see cref="T:System.IO.TextReader"/>
            /
            <see cref="T:System.IO.Stream"/>
            and then treat it
            like a
            <code>char[]</code>
            buffer. Can also pass in a
            <see cref="T:System.String"/>
            or
            <code>char[]</code>
            to use.
            <p>If you need encoding, pass in stream/reader with correct encoding.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.ICharStream">
            <summary>A source of characters for an ANTLR lexer.</summary>
            <remarks>A source of characters for an ANTLR lexer.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.IIntStream">
            <summary>A simple stream of symbols whose values are represented as integers.</summary>
            <remarks>
            A simple stream of symbols whose values are represented as integers. This
            interface provides <em>marked ranges</em> with support for a minimum level
            of buffering necessary to implement arbitrary lookahead during prediction.
            For more information on marked ranges, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            .
            <p><strong>Initializing Methods:</strong> Some methods in this interface have
            unspecified behavior if no call to an initializing method has occurred after
            the stream was constructed. The following is a list of initializing methods:</p>
            <ul>
            <li>
            <see cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)"/>
            </li>
            <li>
            <see cref="M:Antlr4.Runtime.IIntStream.Consume"/>
            </li>
            <li>
            <see cref="P:Antlr4.Runtime.IIntStream.Size"/>
            </li>
            </ul>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Consume">
            <summary>Consumes the current symbol in the stream.</summary>
            <remarks>
            Consumes the current symbol in the stream. This method has the following
            effects:
            <ul>
            <li><strong>Forward movement:</strong> The value of
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            before calling this method is less than the value of
            <code>index()</code>
            after calling this method.</li>
            <li><strong>Ordered lookahead:</strong> The value of
            <code>LA(1)</code>
            before
            calling this method becomes the value of
            <code>LA(-1)</code>
            after calling
            this method.</li>
            </ul>
            Note that calling this method does not guarantee that
            <code>index()</code>
            is
            incremented by exactly 1, as that would preclude the ability to implement
            filtering streams (e.g.
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            which distinguishes
            between "on-channel" and "off-channel" tokens).
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            if an attempt is made to consume the the
            end of the stream (i.e. if
            <code>LA(1)==</code>
            <see cref="F:Antlr4.Runtime.IntStreamConstants.Eof">EOF</see>
            before calling
            <code>consume</code>
            ).
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.La(System.Int32)">
            <summary>
            Gets the value of the symbol at offset
            <code>i</code>
            from the current
            position. When
            <code>i==1</code>
            , this method returns the value of the current
            symbol in the stream (which is the next symbol to be consumed). When
            <code>i==-1</code>
            , this method returns the value of the previously read
            symbol in the stream. It is not valid to call this method with
            <code>i==0</code>
            , but the specific behavior is unspecified because this
            method is frequently called from performance-critical code.
            <p>This method is guaranteed to succeed if any of the following are true:</p>
            <ul>
            <li>
            <code>i&gt;0</code>
            </li>
            <li>
            <code>i==-1</code>
            and
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            returns a value greater
            than the value of
            <code>index()</code>
            after the stream was constructed
            and
            <code>LA(1)</code>
            was called in that order. Specifying the current
            <code>index()</code>
            relative to the index after the stream was created
            allows for filtering implementations that do not return every symbol
            from the underlying source. Specifying the call to
            <code>LA(1)</code>
            allows for lazily initialized streams.</li>
            <li>
            <code>LA(i)</code>
            refers to a symbol consumed within a marked region
            that has not yet been released.</li>
            </ul>
            <p>If
            <code>i</code>
            represents a position at or beyond the end of the stream,
            this method returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.Eof"/>
            .</p>
            <p>The return value is unspecified if
            <code>i&lt;0</code>
            and fewer than
            <code>-i</code>
            calls to
            <see cref="M:Antlr4.Runtime.IIntStream.Consume">consume()</see>
            have occurred from the beginning of
            the stream before calling this method.</p>
            </summary>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            retrieving the value of the specified symbol
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Mark">
            <summary>
            A mark provides a guarantee that
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">seek()</see>
            operations will be
            valid over a "marked range" extending from the index where
            <code>mark()</code>
            was called to the current
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            . This allows the use of
            streaming input sources by specifying the minimum buffering requirements
            to support arbitrary lookahead during prediction.
            <p>The returned mark is an opaque handle (type
            <code>int</code>
            ) which is passed
            to
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release()</see>
            when the guarantees provided by the marked
            range are no longer necessary. When calls to
            <code>mark()</code>
            /
            <code>release()</code>
            are nested, the marks must be released
            in reverse order of which they were obtained. Since marked regions are
            used during performance-critical sections of prediction, the specific
            behavior of invalid usage is unspecified (i.e. a mark is not released, or
            a mark is released twice, or marks are not released in reverse order from
            which they were created).</p>
            <p>The behavior of this method is unspecified if no call to an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream was
            constructed.</p>
            <p>This method does not change the current position in the input stream.</p>
            <p>The following example shows the use of
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">mark()</see>
            ,
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release(mark)</see>
            ,
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            , and
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">seek(index)</see>
            as part of an operation to safely work within a
            marked region, then restore the stream position to its original value and
            release the mark.</p>
            <pre>
            IntStream stream = ...;
            int index = -1;
            int mark = stream.mark();
            try {
            index = stream.index();
            // perform work here...
            } finally {
            if (index != -1) {
            stream.seek(index);
            }
            stream.release(mark);
            }
            </pre>
            </summary>
            <returns>
            An opaque marker which should be passed to
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release()</see>
            when the marked range is no longer required.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">
            <summary>
            This method releases a marked range created by a call to
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">mark()</see>
            . Calls to
            <code>release()</code>
            must appear in the
            reverse order of the corresponding calls to
            <code>mark()</code>
            . If a mark is
            released twice, or if marks are not released in reverse order of the
            corresponding calls to
            <code>mark()</code>
            , the behavior is unspecified.
            <p>For more information and an example, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            .</p>
            </summary>
            <param name="marker">
            A marker returned by a call to
            <code>mark()</code>
            .
            </param>
            <seealso cref="M:Antlr4.Runtime.IIntStream.Mark"/>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">
            <summary>
            Set the input cursor to the position indicated by
            <code>index</code>
            . If the
            specified index lies past the end of the stream, the operation behaves as
            though
            <code>index</code>
            was the index of the EOF symbol. After this method
            returns without throwing an exception, the at least one of the following
            will be true.
            <ul>
            <li>
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            will return the index of the first symbol
            appearing at or after the specified
            <code>index</code>
            . Specifically,
            implementations which filter their sources should automatically
            adjust
            <code>index</code>
            forward the minimum amount required for the
            operation to target a non-ignored symbol.</li>
            <li>
            <code>LA(1)</code>
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.Eof"/>
            </li>
            </ul>
            This operation is guaranteed to not throw an exception if
            <code>index</code>
            lies within a marked region. For more information on marked regions, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            . The behavior of this method is unspecified if no call to
            an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream
            was constructed.
            </summary>
            <param name="index">The absolute index to seek to.</param>
            <exception cref="T:System.ArgumentException">
            if
            <code>index</code>
            is less than 0
            </exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            seeking to the specified index
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.Index">
            <summary>
            Return the index into the stream of the input symbol referred to by
            <code>LA(1)</code>
            .
            <p>The behavior of this method is unspecified if no call to an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream was
            constructed.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.Size">
            <summary>
            Returns the total number of symbols in the stream, including a single EOF
            symbol.
            </summary>
            <remarks>
            Returns the total number of symbols in the stream, including a single EOF
            symbol.
            </remarks>
            <exception cref="T:System.NotSupportedException">
            if the size of the stream is
            unknown.
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.SourceName">
            <summary>Gets the name of the underlying symbol source.</summary>
            <remarks>
            Gets the name of the underlying symbol source. This method returns a
            non-null, non-empty string. If such a name is not known, this method
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName"/>
            .
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ICharStream.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            This method returns the text for a range of characters within this input
            stream.
            </summary>
            <remarks>
            This method returns the text for a range of characters within this input
            stream. This method is guaranteed to not throw an exception if the
            specified
            <code>interval</code>
            lies entirely within a marked range. For more
            information about marked ranges, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            .
            </remarks>
            <param name="interval">an interval within the stream</param>
            <returns>the text of the specified interval</returns>
            <exception cref="T:System.ArgumentNullException">
            if
            <code>interval</code>
            is
            <code>null</code>
            </exception>
            <exception cref="T:System.ArgumentException">
            if
            <code>interval.a &lt; 0</code>
            , or if
            <code>interval.b &lt; interval.a - 1</code>
            , or if
            <code>interval.b</code>
            lies at or
            past the end of the stream
            </exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            getting the text of the specified interval
            </exception>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.data">
            <summary>The data being scanned</summary>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.n">
            <summary>How many characters are actually in the buffer</summary>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.p">
            <summary>0..n-1 index into string of next char</summary>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.name">
            <summary>What is name or source of this char stream?</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.String)">
            <summary>Copy data in string to a local char array</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.Char[],System.Int32)">
            <summary>This is the preferred constructor for strings as no data is copied</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.TextReader)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.TextReader,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.TextReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Load(System.IO.TextReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Reset">
            <summary>
            Reset the stream so that it's in the same state it was
            when the object was created *except* the data array is not
            touched.
            </summary>
            <remarks>
            Reset the stream so that it's in the same state it was
            when the object was created *except* the data array is not
            touched.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Mark">
            <summary>mark/release do nothing; we have entire buffer</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Seek(System.Int32)">
            <summary>
            consume() ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine.
            </summary>
            <remarks>
            consume() ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine. If we seek backwards, just set p
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.AntlrInputStream.Index">
            <summary>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.
            </summary>
            <remarks>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.  The index is the index of char to
            be returned from LA(1).
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.#ctor(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.#ctor(System.String,System.Text.Encoding)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.Load(System.String,System.Text.Encoding)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AbstractPredicateTransition">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.Transition">
            <summary>An ATN transition between any two ATN states.</summary>
            <remarks>
            An ATN transition between any two ATN states.  Subclasses define
            atom, set, epsilon, action, predicate, rule transitions.
            <p>This is a one way link.  It emanates from a state (usually via a list of
            transitions) and has a target state.</p>
            <p>Since we never have to change the ATN transitions once we construct it,
            we can fix these transitions as specific classes. The DFA transitions
            on the other hand need to update the labels as it adds transitions to
            the states. We'll use the term Edge for the DFA to distinguish them from
            ATN transitions.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.Transition.target">
            <summary>The target of this transition.</summary>
            <remarks>The target of this transition.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.Transition.IsEpsilon">
            <summary>Determines if the transition is an "epsilon" transition.</summary>
            <remarks>
            Determines if the transition is an "epsilon" transition.
            <p>The default implementation returns
            <code>false</code>
            .</p>
            </remarks>
            <returns>
            
            <code>true</code>
            if traversing this transition in the ATN does not
            consume an input symbol; otherwise,
            <code>false</code>
            if traversing this
            transition consumes (matches) an input symbol.
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AmbiguityInfo">
            <summary>This class represents profiling event information for an ambiguity.</summary>
            <remarks>
            This class represents profiling event information for an ambiguity.
            Ambiguities are decisions where a particular input resulted in an SLL
            conflict, followed by LL prediction also reaching a conflict state
            (indicating a true ambiguity in the grammar).
            <p>
            This event may be reported during SLL prediction in cases where the
            conflicting SLL configuration set provides sufficient information to
            determine that the SLL conflict is truly an ambiguity. For example, if none
            of the ATN configurations in the conflicting SLL configuration set have
            traversed a global follow transition (i.e.
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.ReachesIntoOuterContext"/>
            is
            <code>false</code>
            for all
            configurations), then the result of SLL prediction for that input is known to
            be equivalent to the result of LL prediction for that input.</p>
            <p>
            In some cases, the minimum represented alternative in the conflicting LL
            configuration set is not equal to the minimum represented alternative in the
            conflicting SLL configuration set. Grammars and inputs which result in this
            scenario are unable to use
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Sll"/>
            , which in turn means
            they cannot use the two-stage parsing strategy to improve parsing performance
            for that input.</p>
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ReportAmbiguity(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            <seealso cref="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            <since>4.3</since>
        </member>
        <member name="T:Antlr4.Runtime.Atn.DecisionEventInfo">
            <summary>
            This is the base class for gathering detailed information about prediction
            events which occur during parsing.
            </summary>
            <remarks>
            This is the base class for gathering detailed information about prediction
            events which occur during parsing.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.decision">
            <summary>The invoked decision number which this event is related to.</summary>
            <remarks>The invoked decision number which this event is related to.</remarks>
            <seealso cref="F:Antlr4.Runtime.Atn.ATN.decisionToState"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.state">
            <summary>
            The simulator state containing additional information relevant to the
            prediction state when the current event occurred, or
            <code>null</code>
            if no
            additional information is relevant or available.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.input">
            <summary>The input token stream which is being parsed.</summary>
            <remarks>The input token stream which is being parsed.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.startIndex">
            <summary>
            The token index in the input stream at which the current prediction was
            originally invoked.
            </summary>
            <remarks>
            The token index in the input stream at which the current prediction was
            originally invoked.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.stopIndex">
            <summary>The token index in the input stream at which the current event occurred.</summary>
            <remarks>The token index in the input stream at which the current event occurred.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.fullCtx">
            <summary>
            <code>true</code>
            if the current event occurred during LL prediction;
            otherwise,
            <code>false</code>
            if the input occurred during SLL prediction.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.AmbiguityInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.AmbiguityInfo"/>
            class with the
            specified detailed ambiguity information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state identifying the ambiguous
            alternatives for the current input
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">
            The index at which the ambiguity was identified during
            prediction
            </param>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionContext.cachedHashCode">
            <summary>
            Stores the computed hash code of this
            <see cref="T:Antlr4.Runtime.Atn.PredictionContext"/>
            . The hash
            code is computed in parts to match the following reference algorithm.
            <pre>
            private int referenceHashCode() {
            int hash =
            <see cref="M:Antlr4.Runtime.Misc.MurmurHash.Initialize">MurmurHash.initialize</see>
            (
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.InitialHash"/>
            );
            for (int i = 0; i &lt;
            <see cref="P:Antlr4.Runtime.Atn.PredictionContext.Size"/>
            ; i++) {
            hash =
            <see cref="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Int32)">MurmurHash.update</see>
            (hash,
            <see cref="M:Antlr4.Runtime.Atn.PredictionContext.GetParent(System.Int32)">getParent</see>
            (i));
            }
            for (int i = 0; i &lt;
            <see cref="P:Antlr4.Runtime.Atn.PredictionContext.Size"/>
            ; i++) {
            hash =
            <see cref="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Int32)">MurmurHash.update</see>
            (hash,
            <see cref="M:Antlr4.Runtime.Atn.PredictionContext.GetReturnState(System.Int32)">getReturnState</see>
            (i));
            }
            hash =
            <see cref="M:Antlr4.Runtime.Misc.MurmurHash.Finish(System.Int32,System.Int32)">MurmurHash.finish</see>
            (hash, 2 *
            <see cref="P:Antlr4.Runtime.Atn.PredictionContext.Size"/>
            );
            return hash;
            }
            </pre>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.decisionToState">
            <summary>
            Each subrule/rule is a decision point and we must track them so we
            can go back later and build DFA predictors for them.
            </summary>
            <remarks>
            Each subrule/rule is a decision point and we must track them so we
            can go back later and build DFA predictors for them.  This includes
            all the rules, subrules, optional blocks, ()+, ()* etc...
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToStartState">
            <summary>Maps from rule index to starting state number.</summary>
            <remarks>Maps from rule index to starting state number.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToStopState">
            <summary>Maps from rule index to stop state number.</summary>
            <remarks>Maps from rule index to stop state number.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.grammarType">
            <summary>The type of the ATN.</summary>
            <remarks>The type of the ATN.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.maxTokenType">
            <summary>The maximum value for any symbol recognized by a transition in the ATN.</summary>
            <remarks>The maximum value for any symbol recognized by a transition in the ATN.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToTokenType">
            <summary>For lexer ATNs, this maps the rule index to the resulting token type.</summary>
            <remarks>
            For lexer ATNs, this maps the rule index to the resulting token type.
            For parser ATNs, this maps the rule index to the generated bypass token
            type if the
            <see cref="P:Antlr4.Runtime.Atn.ATNDeserializationOptions.GenerateRuleBypassTransitions"/>
            deserialization option was specified; otherwise, this is
            <code>null</code>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.lexerActions">
            <summary>
            For lexer ATNs, this is an array of
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            objects which may
            be referenced by action transitions in the ATN.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.#ctor(Antlr4.Runtime.Atn.ATNType,System.Int32)">
            <summary>Used for runtime deserialization of ATNs from strings</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.NextTokens(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext)">
            <summary>
            Compute the set of valid tokens that can occur starting in state
            <code>s</code>
            .
            If
            <code>ctx</code>
            is
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal"/>
            , the set of tokens will not include what can follow
            the rule surrounding
            <code>s</code>
            . In other words, the set will be
            restricted to tokens reachable staying within
            <code>s</code>
            's rule.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.NextTokens(Antlr4.Runtime.Atn.ATNState)">
            <summary>
            Compute the set of valid tokens that can occur starting in
            <code>s</code>
            and
            staying in same rule.
            <see cref="F:Antlr4.Runtime.TokenConstants.Epsilon"/>
            is in set if we reach end of
            rule.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.GetExpectedTokens(System.Int32,Antlr4.Runtime.RuleContext)">
            <summary>
            Computes the set of input symbols which could follow ATN state number
            <code>stateNumber</code>
            in the specified full
            <code>context</code>
            . This method
            considers the complete parser context, but does not evaluate semantic
            predicates (i.e. all predicates encountered during the calculation are
            assumed true). If a path in the ATN exists from the starting state to the
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            of the outermost context without matching any
            symbols,
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            is added to the returned set.
            <p>If
            <code>context</code>
            is
            <code>null</code>
            , it is treated as
            <see cref="P:Antlr4.Runtime.ParserRuleContext.EmptyContext"/>
            .</p>
            </summary>
            <param name="stateNumber">the ATN state number</param>
            <param name="context">the full parse context</param>
            <returns>
            The set of potentially valid input symbols which could follow the
            specified state in the specified context.
            </returns>
            <exception cref="T:System.ArgumentException">
            if the ATN does not contain a state with
            number
            <code>stateNumber</code>
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNConfig">
            <summary>A tuple: (ATN state, predicted alt, syntactic, semantic context).</summary>
            <remarks>
            A tuple: (ATN state, predicted alt, syntactic, semantic context).
            The syntactic context is a graph-structured stack node whose
            path(s) to the root is the rule invocation(s)
            chain used to arrive at the state.  The semantic context is
            the tree of semantic predicates encountered before reaching
            an ATN state.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.state">
            <summary>The ATN state associated with this configuration</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.context">
            <summary>
            The stack of invoking states leading to the rule/states associated
            with this config.
            </summary>
            <remarks>
            The stack of invoking states leading to the rule/states associated
            with this config.  We track only those contexts pushed during
            execution of the ATN simulator.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNConfig.Equals(System.Object)">
            <summary>
            An ATN configuration is equal to another if both have
            the same state, they predict the same alternative, and
            syntactic/semantic contexts are the same.
            </summary>
            <remarks>
            An ATN configuration is equal to another if both have
            the same state, they predict the same alternative, and
            syntactic/semantic contexts are the same.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfig.State">
            <summary>Gets the ATN state associated with this configuration.</summary>
            <remarks>Gets the ATN state associated with this configuration.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfig.Alt">
            <summary>What alt (or lexer rule) is predicted by this configuration.</summary>
            <remarks>What alt (or lexer rule) is predicted by this configuration.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfig.OuterContextDepth">
            <summary>
            We cannot execute predicates dependent upon local context unless
            we know for sure we are in the correct context.
            </summary>
            <remarks>
            We cannot execute predicates dependent upon local context unless
            we know for sure we are in the correct context. Because there is
            no way to do this efficiently, we simply cannot evaluate
            dependent predicates unless we are in the rule that initially
            invokes the ATN simulator.
            closure() tracks the depth of how far we dip into the
            outer context: depth &gt; 0.  Note that it may not be totally
            accurate depth since I don't ever decrement. TODO: make it a boolean then
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNConfigSet">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.mergedConfigs">
            <summary>
            This maps (state, alt) -&gt; merged
            <see cref="T:Antlr4.Runtime.Atn.ATNConfig"/>
            . The key does not account for
            the
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.SemanticContext"/>
            of the value, which is only a problem if a single
            <code>ATNConfigSet</code>
            contains two configs with the same state and alternative
            but different semantic contexts. When this case arises, the first config
            added to this map stays, and the remaining configs are placed in
            <see cref="F:Antlr4.Runtime.Atn.ATNConfigSet.unmerged"/>
            .
            <p/>
            This map is only used for optimizing the process of adding configs to the set,
            and is
            <code>null</code>
            for read-only sets stored in the DFA.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.unmerged">
            <summary>
            This is an "overflow" list holding configs which cannot be merged with one
            of the configs in
            <see cref="F:Antlr4.Runtime.Atn.ATNConfigSet.mergedConfigs"/>
            but have a colliding key. This
            occurs when two configs in the set have the same state and alternative but
            different semantic contexts.
            <p/>
            This list is only used for optimizing the process of adding configs to the set,
            and is
            <code>null</code>
            for read-only sets stored in the DFA.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.configs">
            <summary>This is a list of all configs in this set.</summary>
            <remarks>This is a list of all configs in this set.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.outermostConfigSet">
            <summary>
            When
            <code>true</code>
            , this config set represents configurations where the entire
            outer context has been consumed by the ATN interpreter. This prevents the
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.Closure(Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.ATNConfigSet,System.Boolean,System.Boolean,Antlr4.Runtime.Atn.PredictionContextCache,System.Boolean)"/>
            from pursuing the global FOLLOW when a
            rule stop state is reached with an empty prediction context.
            <p/>
            Note:
            <code>outermostConfigSet</code>
            and
            <see cref="F:Antlr4.Runtime.Atn.ATNConfigSet.dipsIntoOuterContext"/>
            should never
            be true at the same time.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfigSet.RepresentedAlternatives">
            <summary>
            Get the set of all alternatives represented by configurations in this
            set.
            </summary>
            <remarks>
            Get the set of all alternatives represented by configurations in this
            set.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNDeserializationOptions">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNDeserializer">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.BaseSerializedUuid">
            <summary>This is the earliest supported serialized UUID.</summary>
            <remarks>This is the earliest supported serialized UUID.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.AddedLexerActions">
            <summary>
            This UUID indicates an extension of
            <see cref="F:Antlr4.Runtime.Atn.ATNDeserializer.BaseSerializedUuid"/>
            for the addition of lexer actions encoded as a sequence of
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            instances.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.SupportedUuids">
            <summary>
            This list contains all of the currently supported UUIDs, ordered by when
            the feature first appeared in this branch.
            </summary>
            <remarks>
            This list contains all of the currently supported UUIDs, ordered by when
            the feature first appeared in this branch.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.SerializedUuid">
            <summary>This is the current serialized UUID.</summary>
            <remarks>This is the current serialized UUID.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNDeserializer.IsFeatureSupported(System.Guid,System.Guid)">
            <summary>
            Determines if a particular serialized representation of an ATN supports
            a particular feature, identified by the
            <see cref="T:System.Guid"/>
            used for serializing
            the ATN at the time the feature was first introduced.
            </summary>
            <param name="feature">
            The
            <see cref="T:System.Guid"/>
            marking the first time the feature was
            supported in the serialized ATN.
            </param>
            <param name="actualUuid">
            The
            <see cref="T:System.Guid"/>
            of the actual serialized ATN which is
            currently being deserialized.
            </param>
            <returns>
            
            <code>true</code>
            if the
            <code>actualUuid</code>
            value represents a
            serialized ATN at or after the feature identified by
            <code>feature</code>
            was
            introduced; otherwise,
            <code>false</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNDeserializer.MarkPrecedenceDecisions(Antlr4.Runtime.Atn.ATN)">
            <summary>
            Analyze the
            <see cref="T:Antlr4.Runtime.Atn.StarLoopEntryState"/>
            states in the specified ATN to set
            the
            <see cref="F:Antlr4.Runtime.Atn.StarLoopEntryState.precedenceRuleDecision"/>
            field to the
            correct value.
            </summary>
            <param name="atn">The ATN.</param>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNSimulator.SerializedUuid">
            <summary>This is the current serialized UUID.</summary>
            <remarks>This is the current serialized UUID.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNSimulator.Error">
            <summary>Must distinguish between missing edge and edge we know leads nowhere</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNSimulator.ClearDFA">
            <summary>Clear the DFA cache used by the current instance.</summary>
            <remarks>
            Clear the DFA cache used by the current instance. Since the DFA cache may
            be shared by multiple ATN simulators, this method may affect the
            performance (but not accuracy) of other parsers which are being used
            concurrently.
            </remarks>
            <exception cref="T:System.NotSupportedException">
            if the current instance does not
            support clearing the DFA.
            </exception>
            <since>4.3</since>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNState">
            <summary>
            The following images show the relation of states and
            <see cref="F:Antlr4.Runtime.Atn.ATNState.transitions"/>
            for various grammar constructs.
            <ul>
            <li>Solid edges marked with an Îµ indicate a required
            <see cref="T:Antlr4.Runtime.Atn.EpsilonTransition"/>
            .</li>
            <li>Dashed edges indicate locations where any transition derived from
            <see cref="M:Antlr4.Runtime.Atn.ATNState.Transition(System.Int32)"/>
            might appear.</li>
            <li>Dashed nodes are place holders for either a sequence of linked
            <see cref="T:Antlr4.Runtime.Atn.BasicState"/>
            states or the inclusion of a block representing a nested
            construct in one of the forms below.</li>
            <li>Nodes showing multiple outgoing alternatives with a
            <code>...</code>
            support
            any number of alternatives (one or more). Nodes without the
            <code>...</code>
            only
            support the exact number of alternatives shown in the diagram.</li>
            </ul>
            <h2>Basic Blocks</h2>
            <h3>Rule</h3>
            <embed src="images/Rule.svg" type="image/svg+xml"/>
            <h3>Block of 1 or more alternatives</h3>
            <embed src="images/Block.svg" type="image/svg+xml"/>
            <h2>Greedy Loops</h2>
            <h3>Greedy Closure:
            <code>(...)*</code>
            </h3>
            <embed src="images/ClosureGreedy.svg" type="image/svg+xml"/>
            <h3>Greedy Positive Closure:
            <code>(...)+</code>
            </h3>
            <embed src="images/PositiveClosureGreedy.svg" type="image/svg+xml"/>
            <h3>Greedy Optional:
            <code>(...)?</code>
            </h3>
            <embed src="images/OptionalGreedy.svg" type="image/svg+xml"/>
            <h2>Non-Greedy Loops</h2>
            <h3>Non-Greedy Closure:
            <code>(...)*?</code>
            </h3>
            <embed src="images/ClosureNonGreedy.svg" type="image/svg+xml"/>
            <h3>Non-Greedy Positive Closure:
            <code>(...)+?</code>
            </h3>
            <embed src="images/PositiveClosureNonGreedy.svg" type="image/svg+xml"/>
            <h3>Non-Greedy Optional:
            <code>(...)??</code>
            </h3>
            <embed src="images/OptionalNonGreedy.svg" type="image/svg+xml"/>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNState.atn">
            <summary>Which ATN are we in?</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNState.transitions">
            <summary>Track the transitions emanating from this ATN state.</summary>
            <remarks>Track the transitions emanating from this ATN state.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNState.nextTokenWithinRule">
            <summary>Used to cache lookahead during parsing, not used during construction</summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNState.StateNumber">
            <summary>Gets the state number.</summary>
            <remarks>Gets the state number.</remarks>
            <returns>the state number</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNState.NonStopStateNumber">
            <summary>
            For all states except
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            , this returns the state
            number. Returns -1 for stop states.
            </summary>
            <returns>
            -1 for
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            , otherwise the state number
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNType">
            <summary>Represents the type of recognizer an ATN applies to.</summary>
            <remarks>Represents the type of recognizer an ATN applies to.</remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AtomTransition">
            <summary>TODO: make all transitions sets? no, should remove set edges</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.AtomTransition.label">
            <summary>The token type or character value; or, signifies special label.</summary>
            <remarks>The token type or character value; or, signifies special label.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BasicBlockStartState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BlockStartState">
            <summary>
            The start of a regular
            <code>(...)</code>
            block.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BasicState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BlockEndState">
            <summary>
            Terminal node of a simple
            <code>(a|b|c)</code>
            block.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ContextSensitivityInfo">
            <summary>This class represents profiling event information for a context sensitivity.</summary>
            <remarks>
            This class represents profiling event information for a context sensitivity.
            Context sensitivities are decisions where a particular input resulted in an
            SLL conflict, but LL prediction produced a single unique alternative.
            <p>
            In some cases, the unique alternative identified by LL prediction is not
            equal to the minimum represented alternative in the conflicting SLL
            configuration set. Grammars and inputs which result in this scenario are
            unable to use
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Sll"/>
            , which in turn means they cannot use
            the two-stage parsing strategy to improve parsing performance for that
            input.</p>
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ReportContextSensitivity(Antlr4.Runtime.Dfa.DFA,System.Int32,Antlr4.Runtime.Atn.SimulatorState,System.Int32,System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ContextSensitivityInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.ContextSensitivityInfo"/>
            class
            with the specified detailed context sensitivity information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state containing the unique
            alternative identified by full-context prediction
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">
            The index at which the context sensitivity was
            identified during full-context prediction
            </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.DecisionInfo">
            <summary>This class contains profiling gathered for a particular decision.</summary>
            <remarks>
            This class contains profiling gathered for a particular decision.
            <p>
            Parsing performance in ANTLR 4 is heavily influenced by both static factors
            (e.g. the form of the rules in the grammar) and dynamic factors (e.g. the
            choice of input and the state of the DFA cache at the time profiling
            operations are started). For best results, gather and use aggregate
            statistics from a large sample of inputs representing the inputs expected in
            production before using the results to make changes in the grammar.</p>
            </remarks>
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.decision">
            <summary>
            The decision number, which is an index into
            <see cref="F:Antlr4.Runtime.Atn.ATN.decisionToState"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.invocations">
            <summary>
            The total number of times
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AdaptivePredict(Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.ParserRuleContext)"/>
            was
            invoked for this decision.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.timeInPrediction">
            <summary>
            The total time spent in
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AdaptivePredict(Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.ParserRuleContext)"/>
            for
            this decision, in nanoseconds.
            <p>
            The value of this field is computed by <see cref="T:System.Diagnostics.Stopwatch"/>,
            and is not adjusted to compensate for JIT
            and/or garbage collection overhead. For best accuracy, perform profiling
            in a separate process which is warmed up by parsing the input prior to
            profiling. If desired, call <see cref="M:Antlr4.Runtime.Atn.ATNSimulator.ClearDFA"/>
            to reset the DFA cache to its initial
            state before starting the profiling measurement pass.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_TotalLook">
            <summary>The sum of the lookahead required for SLL prediction for this decision.</summary>
            <remarks>
            The sum of the lookahead required for SLL prediction for this decision.
            Note that SLL prediction is used before LL prediction for performance
            reasons even when
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            or
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection"/>
            is used.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MinLook">
            <summary>
            Gets the minimum lookahead required for any single SLL prediction to
            complete for this decision, by reaching a unique prediction, reaching an
            SLL conflict state, or encountering a syntax error.
            </summary>
            <remarks>
            Gets the minimum lookahead required for any single SLL prediction to
            complete for this decision, by reaching a unique prediction, reaching an
            SLL conflict state, or encountering a syntax error.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MaxLook">
            <summary>
            Gets the maximum lookahead required for any single SLL prediction to
            complete for this decision, by reaching a unique prediction, reaching an
            SLL conflict state, or encountering a syntax error.
            </summary>
            <remarks>
            Gets the maximum lookahead required for any single SLL prediction to
            complete for this decision, by reaching a unique prediction, reaching an
            SLL conflict state, or encountering a syntax error.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MaxLookEvent">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.Atn.LookaheadEventInfo"/>
            associated with the event where the
            <see cref="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MaxLook"/>
            value was set.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_TotalLook">
            <summary>The sum of the lookahead required for LL prediction for this decision.</summary>
            <remarks>
            The sum of the lookahead required for LL prediction for this decision.
            Note that LL prediction is only used when SLL prediction reaches a
            conflict state.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MinLook">
            <summary>
            Gets the minimum lookahead required for any single LL prediction to
            complete for this decision.
            </summary>
            <remarks>
            Gets the minimum lookahead required for any single LL prediction to
            complete for this decision. An LL prediction completes when the algorithm
            reaches a unique prediction, a conflict state (for
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            , an ambiguity state (for
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection"/>
            , or a syntax error.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MaxLook">
            <summary>
            Gets the maximum lookahead required for any single LL prediction to
            complete for this decision.
            </summary>
            <remarks>
            Gets the maximum lookahead required for any single LL prediction to
            complete for this decision. An LL prediction completes when the algorithm
            reaches a unique prediction, a conflict state (for
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            , an ambiguity state (for
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection"/>
            , or a syntax error.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MaxLookEvent">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.Atn.LookaheadEventInfo"/>
            associated with the event where the
            <see cref="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MaxLook"/>
            value was set.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.contextSensitivities">
            <summary>
            A collection of
            <see cref="T:Antlr4.Runtime.Atn.ContextSensitivityInfo"/>
            instances describing the
            context sensitivities encountered during LL prediction for this decision.
            </summary>
            <seealso cref="T:Antlr4.Runtime.Atn.ContextSensitivityInfo"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.errors">
            <summary>
            A collection of
            <see cref="T:Antlr4.Runtime.Atn.ErrorInfo"/>
            instances describing the parse errors
            identified during calls to
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AdaptivePredict(Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.ParserRuleContext)"/>
            for
            this decision.
            </summary>
            <seealso cref="T:Antlr4.Runtime.Atn.ErrorInfo"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.ambiguities">
            <summary>
            A collection of
            <see cref="T:Antlr4.Runtime.Atn.AmbiguityInfo"/>
            instances describing the
            ambiguities encountered during LL prediction for this decision.
            </summary>
            <seealso cref="T:Antlr4.Runtime.Atn.AmbiguityInfo"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.predicateEvals">
            <summary>
            A collection of
            <see cref="T:Antlr4.Runtime.Atn.PredicateEvalInfo"/>
            instances describing the
            results of evaluating individual predicates during prediction for this
            decision.
            </summary>
            <seealso cref="T:Antlr4.Runtime.Atn.PredicateEvalInfo"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_ATNTransitions">
            <summary>
            The total number of ATN transitions required during SLL prediction for
            this decision.
            </summary>
            <remarks>
            The total number of ATN transitions required during SLL prediction for
            this decision. An ATN transition is determined by the number of times the
            DFA does not contain an edge that is required for prediction, resulting
            in on-the-fly computation of that edge.
            <p>
            If DFA caching of SLL transitions is employed by the implementation, ATN
            computation may cache the computed edge for efficient lookup during
            future parsing of this decision. Otherwise, the SLL parsing algorithm
            will use ATN transitions exclusively.</p>
            </remarks>
            <seealso cref="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_ATNTransitions"/>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ComputeTargetState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.ParserRuleContext,System.Int32,System.Boolean,Antlr4.Runtime.Atn.PredictionContextCache)"/>
            <seealso cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.ComputeTargetState(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Dfa.DFAState,System.Int32)"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_DFATransitions">
            <summary>
            The total number of DFA transitions required during SLL prediction for
            this decision.
            </summary>
            <remarks>
            The total number of DFA transitions required during SLL prediction for
            this decision.
            <p>If the ATN simulator implementation does not use DFA caching for SLL
            transitions, this value will be 0.</p>
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_Fallback">
            <summary>
            Gets the total number of times SLL prediction completed in a conflict
            state, resulting in fallback to LL prediction.
            </summary>
            <remarks>
            Gets the total number of times SLL prediction completed in a conflict
            state, resulting in fallback to LL prediction.
            <p>Note that this value is not related to whether or not
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Sll"/>
            may be used successfully with a particular
            grammar. If the ambiguity resolution algorithm applied to the SLL
            conflicts for this decision produce the same result as LL prediction for
            this decision,
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Sll"/>
            would produce the same overall
            parsing result as
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            .</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_ATNTransitions">
            <summary>
            The total number of ATN transitions required during LL prediction for
            this decision.
            </summary>
            <remarks>
            The total number of ATN transitions required during LL prediction for
            this decision. An ATN transition is determined by the number of times the
            DFA does not contain an edge that is required for prediction, resulting
            in on-the-fly computation of that edge.
            <p>
            If DFA caching of LL transitions is employed by the implementation, ATN
            computation may cache the computed edge for efficient lookup during
            future parsing of this decision. Otherwise, the LL parsing algorithm will
            use ATN transitions exclusively.</p>
            </remarks>
            <seealso cref="F:Antlr4.Runtime.Atn.DecisionInfo.LL_DFATransitions"/>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ComputeTargetState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.ParserRuleContext,System.Int32,System.Boolean,Antlr4.Runtime.Atn.PredictionContextCache)"/>
            <seealso cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.ComputeTargetState(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Dfa.DFAState,System.Int32)"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_DFATransitions">
            <summary>
            The total number of DFA transitions required during LL prediction for
            this decision.
            </summary>
            <remarks>
            The total number of DFA transitions required during LL prediction for
            this decision.
            <p>If the ATN simulator implementation does not use DFA caching for LL
            transitions, this value will be 0.</p>
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.Atn.DecisionInfo.#ctor(System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.DecisionInfo"/>
            class to contain
            statistics for a particular decision.
            </summary>
            <param name="decision">The decision number</param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ErrorInfo">
            <summary>
            This class represents profiling event information for a syntax error
            identified during prediction.
            </summary>
            <remarks>
            This class represents profiling event information for a syntax error
            identified during prediction. Syntax errors occur when the prediction
            algorithm is unable to identify an alternative which would lead to a
            successful parse.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(Antlr4.Runtime.IToken,System.String,Antlr4.Runtime.RecognitionException)"/>
            <seealso cref="M:Antlr4.Runtime.IAntlrErrorListener`1.SyntaxError(Antlr4.Runtime.IRecognizer,`0,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)"/>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ErrorInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.ErrorInfo"/>
            class with the
            specified detailed syntax error information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state reached during prediction
            prior to reaching the
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.Error"/>
            state
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">The index at which the syntax error was identified</param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ILexerAction">
            <summary>
            Represents a single action which can be executed following the successful
            match of a lexer rule.
            </summary>
            <remarks>
            Represents a single action which can be executed following the successful
            match of a lexer rule. Lexer actions are used for both embedded action syntax
            and ANTLR 4's new lexer command syntax.
            </remarks>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ILexerAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            Execute the lexer action in the context of the specified
            <see cref="T:Antlr4.Runtime.Lexer"/>
            .
            <p>For position-dependent actions, the input stream must already be
            positioned correctly prior to calling this method.</p>
            </summary>
            <param name="lexer">The lexer instance.</param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ILexerAction.ActionType">
            <summary>Gets the serialization type of the lexer action.</summary>
            <remarks>Gets the serialization type of the lexer action.</remarks>
            <returns>The serialization type of the lexer action.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ILexerAction.IsPositionDependent">
            <summary>Gets whether the lexer action is position-dependent.</summary>
            <remarks>
            Gets whether the lexer action is position-dependent. Position-dependent
            actions may have different semantics depending on the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            index at the time the action is executed.
            <p>Many lexer commands, including
            <code>type</code>
            ,
            <code>skip</code>
            , and
            <code>more</code>
            , do not check the input index during their execution.
            Actions like this are position-independent, and may be stored more
            efficiently as part of the
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.ActionExecutor"/>
            .</p>
            </remarks>
            <returns>
            
            <code>true</code>
            if the lexer action semantics can be affected by the
            position of the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            at the time it is executed;
            otherwise,
            <code>false</code>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerActionExecutor">
            <summary>
            Represents an executor for a sequence of lexer actions which traversed during
            the matching operation of a lexer rule (token).
            </summary>
            <remarks>
            Represents an executor for a sequence of lexer actions which traversed during
            the matching operation of a lexer rule (token).
            <p>The executor tracks position information for position-dependent lexer actions
            efficiently, ensuring that actions appearing only at the end of the rule do
            not cause bloating of the
            <see cref="T:Antlr4.Runtime.Dfa.DFA"/>
            created for the lexer.</p>
            </remarks>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerActionExecutor.hashCode">
            <summary>
            Caches the result of
            <see cref="F:Antlr4.Runtime.Atn.LexerActionExecutor.hashCode"/>
            since the hash code is an element
            of the performance-critical
            <see cref="M:Antlr4.Runtime.Atn.ATNConfig.GetHashCode"/>
            operation.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.#ctor(Antlr4.Runtime.Atn.ILexerAction[])">
            <summary>
            Constructs an executor for a sequence of
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            actions.
            </summary>
            <param name="lexerActions">The lexer actions to execute.</param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.Append(Antlr4.Runtime.Atn.LexerActionExecutor,Antlr4.Runtime.Atn.ILexerAction)">
            <summary>
            Creates a
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which executes the actions for
            the input
            <code>lexerActionExecutor</code>
            followed by a specified
            <code>lexerAction</code>
            .
            </summary>
            <param name="lexerActionExecutor">
            The executor for actions already traversed by
            the lexer while matching a token within a particular
            <see cref="T:Antlr4.Runtime.Atn.ATNConfig"/>
            . If this is
            <code>null</code>
            , the method behaves as though
            it were an empty executor.
            </param>
            <param name="lexerAction">
            The lexer action to execute after the actions
            specified in
            <code>lexerActionExecutor</code>
            .
            </param>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            for executing the combine actions
            of
            <code>lexerActionExecutor</code>
            and
            <code>lexerAction</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.FixOffsetBeforeMatch(System.Int32)">
            <summary>
            Creates a
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which encodes the current offset
            for position-dependent lexer actions.
            <p>Normally, when the executor encounters lexer actions where
            <see cref="P:Antlr4.Runtime.Atn.ILexerAction.IsPositionDependent"/>
            returns
            <code>true</code>
            , it calls
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
            on the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            to set the input
            position to the <em>end</em> of the current token. This behavior provides
            for efficient DFA representation of lexer actions which appear at the end
            of a lexer rule, even when the lexer rule matches a variable number of
            characters.</p>
            <p>Prior to traversing a match transition in the ATN, the current offset
            from the token start index is assigned to all position-dependent lexer
            actions which have not already been assigned a fixed offset. By storing
            the offsets relative to the token start index, the DFA representation of
            lexer actions which appear in the middle of tokens remains efficient due
            to sharing among tokens of the same length, regardless of their absolute
            position in the input stream.</p>
            <p>If the current executor already has offsets assigned to all
            position-dependent lexer actions, the method returns
            <code>this</code>
            .</p>
            </summary>
            <param name="offset">
            The current offset to assign to all position-dependent
            lexer actions which do not already have offsets assigned.
            </param>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which stores input stream offsets
            for all position-dependent lexer actions.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.Execute(Antlr4.Runtime.Lexer,Antlr4.Runtime.ICharStream,System.Int32)">
            <summary>
            Execute the actions encapsulated by this executor within the context of a
            particular
            <see cref="T:Antlr4.Runtime.Lexer"/>
            .
            <p>This method calls
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
            to set the position of the
            <code>input</code>
            
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            prior to calling
            <see cref="M:Antlr4.Runtime.Atn.ILexerAction.Execute(Antlr4.Runtime.Lexer)"/>
            on a position-dependent action. Before the
            method returns, the input position will be restored to the same position
            it was in when the method was invoked.</p>
            </summary>
            <param name="lexer">The lexer instance.</param>
            <param name="input">
            The input stream which is the source for the current token.
            When this method is called, the current
            <see cref="P:Antlr4.Runtime.IIntStream.Index"/>
            for
            <code>input</code>
            should be the start of the following token, i.e. 1
            character past the end of the current token.
            </param>
            <param name="startIndex">
            The token start index. This value may be passed to
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
            to set the
            <code>input</code>
            position to the beginning
            of the token.
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerActionExecutor.LexerActions">
            <summary>Gets the lexer actions to be executed by this executor.</summary>
            <remarks>Gets the lexer actions to be executed by this executor.</remarks>
            <returns>The lexer actions to be executed by this executor.</returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerActionType">
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerATNSimulator">
            <summary>"dup" of ParserInterpreter</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.startIndex">
            <summary>The current token's starting index into the character stream.</summary>
            <remarks>
            The current token's starting index into the character stream.
            Shared across DFA to ATN simulation in case the ATN fails and the
            DFA did not have a previous accept state. In this case, we use the
            ATN-generated exception object.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.line">
            <summary>line number 1..n within the input</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.charPositionInLine">
            <summary>The index of the character relative to the beginning of the line 0..n-1</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.prevAccept">
            <summary>Used during DFA/ATN exec to record the most recent accept configuration info</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)">
            <summary>Get an existing target state for an edge in the DFA.</summary>
            <remarks>
            Get an existing target state for an edge in the DFA. If the target state
            for the edge has not yet been computed or is otherwise not available,
            this method returns
            <code>null</code>
            .
            </remarks>
            <param name="s">The current DFA state</param>
            <param name="t">The next input symbol</param>
            <returns>
            The existing target DFA state for the given input symbol
            <code>t</code>
            , or
            <code>null</code>
            if the target state for this edge is not
            already cached
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.ComputeTargetState(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Dfa.DFAState,System.Int32)">
            <summary>
            Compute a target state for an edge in the DFA, and attempt to add the
            computed state and corresponding edge to the DFA.
            </summary>
            <remarks>
            Compute a target state for an edge in the DFA, and attempt to add the
            computed state and corresponding edge to the DFA.
            </remarks>
            <param name="input">The input stream</param>
            <param name="s">The current DFA state</param>
            <param name="t">The next input symbol</param>
            <returns>
            The computed target DFA state for the given input symbol
            <code>t</code>
            . If
            <code>t</code>
            does not lead to a valid DFA state, this method
            returns
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.Error"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetReachableConfigSet(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)">
            <summary>
            Given a starting configuration set, figure out all ATN configurations
            we can reach upon input
            <code>t</code>
            . Parameter
            <code>reach</code>
            is a return
            parameter.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.Closure(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Atn.ATNConfig,Antlr4.Runtime.Atn.ATNConfigSet,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Since the alternatives within any lexer decision are ordered by
            preference, this method stops pursuing the closure as soon as an accept
            state is reached.
            </summary>
            <remarks>
            Since the alternatives within any lexer decision are ordered by
            preference, this method stops pursuing the closure as soon as an accept
            state is reached. After the first accept state is reached by depth-first
            search from
            <code>config</code>
            , all other (potentially reachable) states for
            this rule would have a lower priority.
            </remarks>
            <returns>
            
            <code>true</code>
            if an accept state is reached, otherwise
            <code>false</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.EvaluatePredicate(Antlr4.Runtime.ICharStream,System.Int32,System.Int32,System.Boolean)">
            <summary>Evaluate a predicate specified in the lexer.</summary>
            <remarks>
            Evaluate a predicate specified in the lexer.
            <p>If
            <code>speculative</code>
            is
            <code>true</code>
            , this method was called before
            <see cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.Consume(Antlr4.Runtime.ICharStream)"/>
            for the matched character. This method should call
            <see cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.Consume(Antlr4.Runtime.ICharStream)"/>
            before evaluating the predicate to ensure position
            sensitive values, including
            <see cref="P:Antlr4.Runtime.Lexer.Text"/>
            ,
            <see cref="P:Antlr4.Runtime.Lexer.Line"/>
            ,
            and
            <see cref="P:Antlr4.Runtime.Lexer.Column"/>
            , properly reflect the current
            lexer state. This method should restore
            <code>input</code>
            and the simulator
            to the original state before returning (i.e. undo the actions made by the
            call to
            <see cref="M:Antlr4.Runtime.Atn.LexerATNSimulator.Consume(Antlr4.Runtime.ICharStream)"/>
            .</p>
            </remarks>
            <param name="input">The input stream.</param>
            <param name="ruleIndex">The rule containing the predicate.</param>
            <param name="predIndex">The index of the predicate within the rule.</param>
            <param name="speculative">
            
            <code>true</code>
            if the current index in
            <code>input</code>
            is
            one character before the predicate's location.
            </param>
            <returns>
            
            <code>true</code>
            if the specified predicate evaluates to
            <code>true</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.AddDFAState(Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>
            Add a new DFA state if there isn't one with this set of
            configurations already.
            </summary>
            <remarks>
            Add a new DFA state if there isn't one with this set of
            configurations already. This method also detects the first
            configuration containing an ATN rule stop state. Later, when
            traversing the DFA, we will know which rule to accept.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetText(Antlr4.Runtime.ICharStream)">
            <summary>Get the text matched so far for the current token.</summary>
            <remarks>Get the text matched so far for the current token.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerATNSimulator.SimState">
            <summary>
            When we hit an accept state in either the DFA or the ATN, we
            have to notify the character stream to start buffering characters
            via
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            and record the current state. The current sim state
            includes the current index into the input, the current line,
            and current character position in that line. Note that the Lexer is
            tracking the starting line and characterization of the token. These
            variables track the "state" of the simulator when it hits an accept state.
            <p>We track these variables separately for the DFA and ATN simulation
            because the DFA simulation often has to fail over to the ATN
            simulation. If the ATN simulation fails, we need the DFA to fall
            back to its previously accepted state, if any. If the ATN succeeds,
            then the ATN does the accept and the DFA simulator that invoked it
            can simply return the predicted token type.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerChannelAction">
            <summary>
            Implements the
            <code>channel</code>
            lexer action by calling
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            with the assigned channel.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerChannelAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <code>channel</code>
            action with the specified channel value.
            </summary>
            <param name="channel">
            The channel value to pass to
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            .
            </param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerChannelAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerChannelAction.Channel"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerChannelAction.Channel">
            <summary>
            Gets the channel to use for the
            <see cref="T:Antlr4.Runtime.IToken"/>
            created by the lexer.
            </summary>
            <returns>
            The channel to use for the
            <see cref="T:Antlr4.Runtime.IToken"/>
            created by the lexer.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerChannelAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Channel"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerChannelAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <code>false</code>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerCustomAction">
            <summary>
            Executes a custom lexer action by calling
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            with the
            rule and action indexes assigned to the custom action. The implementation of
            a custom action is added to the generated code for the lexer in an override
            of
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            when the grammar is compiled.
            <p>This class may represent embedded actions created with the <code>{...}</code>
            syntax in ANTLR 4, as well as actions created for lexer commands where the
            command argument could not be evaluated when the grammar was compiled.</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerCustomAction.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a custom lexer action with the specified rule and action
            indexes.
            </summary>
            <remarks>
            Constructs a custom lexer action with the specified rule and action
            indexes.
            </remarks>
            <param name="ruleIndex">
            The rule index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </param>
            <param name="actionIndex">
            The action index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerCustomAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>Custom actions are implemented by calling
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            with the
            appropriate rule and action indexes.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.RuleIndex">
            <summary>
            Gets the rule index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </summary>
            <returns>The rule index for the custom action.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.ActionIndex">
            <summary>
            Gets the action index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </summary>
            <returns>The action index for the custom action.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Custom"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.IsPositionDependent">
            <summary>Gets whether the lexer action is position-dependent.</summary>
            <remarks>
            Gets whether the lexer action is position-dependent. Position-dependent
            actions may have different semantics depending on the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            index at the time the action is executed.
            <p>Custom actions are position-dependent since they may represent a
            user-defined embedded action which makes calls to methods like
            <see cref="P:Antlr4.Runtime.Lexer.Text"/>
            .</p>
            </remarks>
            <returns>
            This method returns
            <code>true</code>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerIndexedCustomAction">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            is used for tracking input offsets
            for position-dependent actions within a
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            .
            <p>This action is not serialized as part of the ATN, and is only required for
            position-dependent lexer actions which appear at a location other than the
            end of a rule. For more information about DFA optimizations employed for
            lexer actions, see
            <see cref="M:Antlr4.Runtime.Atn.LexerActionExecutor.Append(Antlr4.Runtime.Atn.LexerActionExecutor,Antlr4.Runtime.Atn.ILexerAction)"/>
            and
            <see cref="M:Antlr4.Runtime.Atn.LexerActionExecutor.FixOffsetBeforeMatch(System.Int32)"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerIndexedCustomAction.#ctor(System.Int32,Antlr4.Runtime.Atn.ILexerAction)">
            <summary>
            Constructs a new indexed custom action by associating a character offset
            with a
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            .
            <p>Note: This class is only required for lexer actions for which
            <see cref="P:Antlr4.Runtime.Atn.ILexerAction.IsPositionDependent"/>
            returns
            <code>true</code>
            .</p>
            </summary>
            <param name="offset">
            The offset into the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            , relative to
            the token start index, at which the specified lexer action should be
            executed.
            </param>
            <param name="action">
            The lexer action to execute at a particular offset in the
            input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            .
            </param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This method calls
            <see cref="M:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Execute(Antlr4.Runtime.Lexer)"/>
            on the result of
            <see cref="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Action"/>
            using the provided
            <code>lexer</code>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Offset">
            <summary>
            Gets the location in the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            at which the lexer
            action should be executed. The value is interpreted as an offset relative
            to the token start index.
            </summary>
            <returns>
            The location in the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            at which the lexer
            action should be executed.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Action">
            <summary>Gets the lexer action to execute.</summary>
            <remarks>Gets the lexer action to execute.</remarks>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            object which executes the lexer action.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns the result of calling
            <see cref="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.ActionType"/>
            on the
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            returned by
            <see cref="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Action"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <code>true</code>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerModeAction">
            <summary>
            Implements the
            <code>mode</code>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.Mode(System.Int32)"/>
            with
            the assigned mode.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerModeAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <code>mode</code>
            action with the specified mode value.
            </summary>
            <param name="mode">
            The mode value to pass to
            <see cref="M:Antlr4.Runtime.Lexer.Mode(System.Int32)"/>
            .
            </param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerModeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.Mode(System.Int32)"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerModeAction.Mode"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerModeAction.Mode">
            <summary>Get the lexer mode this action should transition the lexer to.</summary>
            <remarks>Get the lexer mode this action should transition the lexer to.</remarks>
            <returns>
            The lexer mode for this
            <code>mode</code>
            command.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerModeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Mode"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerModeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <code>false</code>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerMoreAction">
            <summary>
            Implements the
            <code>more</code>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.More"/>
            .
            <p>The
            <code>more</code>
            command does not have any parameters, so this action is
            implemented as a singleton instance exposed by
            <see cref="F:Antlr4.Runtime.Atn.LexerMoreAction.Instance"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerMoreAction.Instance">
            <summary>Provides a singleton instance of this parameterless lexer action.</summary>
            <remarks>Provides a singleton instance of this parameterless lexer action.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerMoreAction.#ctor">
            <summary>
            Constructs the singleton instance of the lexer
            <code>more</code>
            command.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerMoreAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.More"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerMoreAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.More"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerMoreAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <code>false</code>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerPopModeAction">
            <summary>
            Implements the
            <code>popMode</code>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.PopMode"/>
            .
            <p>The
            <code>popMode</code>
            command does not have any parameters, so this action is
            implemented as a singleton instance exposed by
            <see cref="F:Antlr4.Runtime.Atn.LexerPopModeAction.Instance"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerPopModeAction.Instance">
            <summary>Provides a singleton instance of this parameterless lexer action.</summary>
            <remarks>Provides a singleton instance of this parameterless lexer action.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPopModeAction.#ctor">
            <summary>
            Constructs the singleton instance of the lexer
            <code>popMode</code>
            command.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPopModeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.PopMode"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPopModeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.PopMode"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPopModeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <code>false</code>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerPushModeAction">
            <summary>
            Implements the
            <code>pushMode</code>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.PushMode(System.Int32)"/>
            with the assigned mode.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPushModeAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <code>pushMode</code>
            action with the specified mode value.
            </summary>
            <param name="mode">
            The mode value to pass to
            <see cref="M:Antlr4.Runtime.Lexer.PushMode(System.Int32)"/>
            .
            </param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPushModeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.PushMode(System.Int32)"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerPushModeAction.Mode"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPushModeAction.Mode">
            <summary>Get the lexer mode this action should transition the lexer to.</summary>
            <remarks>Get the lexer mode this action should transition the lexer to.</remarks>
            <returns>
            The lexer mode for this
            <code>pushMode</code>
            command.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPushModeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.PushMode"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPushModeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <code>false</code>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerSkipAction">
            <summary>
            Implements the
            <code>skip</code>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.Skip"/>
            .
            <p>The
            <code>skip</code>
            command does not have any parameters, so this action is
            implemented as a singleton instance exposed by
            <see cref="F:Antlr4.Runtime.Atn.LexerSkipAction.Instance"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerSkipAction.Instance">
            <summary>Provides a singleton instance of this parameterless lexer action.</summary>
            <remarks>Provides a singleton instance of this parameterless lexer action.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerSkipAction.#ctor">
            <summary>
            Constructs the singleton instance of the lexer
            <code>skip</code>
            command.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerSkipAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.Skip"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerSkipAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Skip"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerSkipAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <code>false</code>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerTypeAction">
            <summary>
            Implements the
            <code>type</code>
            lexer action by calling
            <see cref="P:Antlr4.Runtime.Lexer.Type"/>
            with the assigned type.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerTypeAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <code>type</code>
            action with the specified token type value.
            </summary>
            <param name="type">
            The type to assign to the token using
            <see cref="P:Antlr4.Runtime.Lexer.Type"/>
            .
            </param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerTypeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="P:Antlr4.Runtime.Lexer.Type"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerTypeAction.Type"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerTypeAction.Type">
            <summary>Gets the type to assign to a token created by the lexer.</summary>
            <remarks>Gets the type to assign to a token created by the lexer.</remarks>
            <returns>The type to assign to a token created by the lexer.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerTypeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Type"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerTypeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <code>false</code>
            .
            </returns>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LL1Analyzer.HitPred">
            <summary>
            Special value added to the lookahead sets to indicate that we hit
            a predicate during analysis if
            <code>seeThruPreds==false</code>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.GetDecisionLookahead(Antlr4.Runtime.Atn.ATNState)">
            <summary>
            Calculates the SLL(1) expected lookahead set for each outgoing transition
            of an
            <see cref="T:Antlr4.Runtime.Atn.ATNState"/>
            . The returned array has one element for each
            outgoing transition in
            <code>s</code>
            . If the closure from transition
            <em>i</em> leads to a semantic predicate before matching a symbol, the
            element at index <em>i</em> of the result will be
            <code>null</code>
            .
            </summary>
            <param name="s">the ATN state</param>
            <returns>
            the expected symbols for each outgoing transition of
            <code>s</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext)">
            <summary>
            Compute set of tokens that can follow
            <code>s</code>
            in the ATN in the
            specified
            <code>ctx</code>
            .
            <p>If
            <code>ctx</code>
            is
            <code>null</code>
            and the end of the rule containing
            <code>s</code>
            is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Epsilon"/>
            is added to the result set.
            If
            <code>ctx</code>
            is not
            <code>null</code>
            and the end of the outermost rule is
            reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            is added to the result set.</p>
            </summary>
            <param name="s">the ATN state</param>
            <param name="ctx">
            the complete parser context, or
            <code>null</code>
            if the context
            should be ignored
            </param>
            <returns>
            The set of tokens that can follow
            <code>s</code>
            in the ATN in the
            specified
            <code>ctx</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext)">
            <summary>
            Compute set of tokens that can follow
            <code>s</code>
            in the ATN in the
            specified
            <code>ctx</code>
            .
            <p>If
            <code>ctx</code>
            is
            <code>null</code>
            and the end of the rule containing
            <code>s</code>
            is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Epsilon"/>
            is added to the result set.
            If
            <see cref="F:Antlr4.Runtime.IntStreamConstants.Eof"/>
            is not
            <code>PredictionContext#EMPTY_LOCAL</code>
            and the end of the outermost rule is
            reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            is added to the result set.</p>
            </summary>
            <param name="s">the ATN state</param>
            <param name="stopState">
            the ATN state to stop at. This can be a
            <see cref="T:Antlr4.Runtime.Atn.BlockEndState"/>
            to detect epsilon paths through a closure.
            </param>
            <param name="ctx">
            the complete parser context, or
            <code>null</code>
            if the context
            should be ignored
            </param>
            <returns>
            The set of tokens that can follow
            <code>s</code>
            in the ATN in the
            specified
            <code>ctx</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext,Antlr4.Runtime.Misc.IntervalSet,System.Collections.Generic.HashSet{Antlr4.Runtime.Atn.ATNConfig},Antlr4.Runtime.Sharpen.BitSet,System.Boolean,System.Boolean)">
            <summary>
            Compute set of tokens that can follow
            <code>s</code>
            in the ATN in the
            specified
            <code>ctx</code>
            .
            <p/>
            If
            <code>ctx</code>
            is
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal"/>
            and
            <code>stopState</code>
            or the end of the rule containing
            <code>s</code>
            is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Epsilon"/>
            is added to the result set. If
            <code>ctx</code>
            is not
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal"/>
            and
            <code>addEOF</code>
            is
            <code>true</code>
            and
            <code>stopState</code>
            or the end of the outermost rule is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            is added to the result set.
            </summary>
            <param name="s">the ATN state.</param>
            <param name="stopState">
            the ATN state to stop at. This can be a
            <see cref="T:Antlr4.Runtime.Atn.BlockEndState"/>
            to detect epsilon paths through a closure.
            </param>
            <param name="ctx">
            The outer context, or
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal"/>
            if
            the outer context should not be used.
            </param>
            <param name="look">The result lookahead set.</param>
            <param name="lookBusy">
            A set used for preventing epsilon closures in the ATN
            from causing a stack overflow. Outside code should pass
            <code>new HashSet&lt;ATNConfig&gt;</code>
            for this argument.
            </param>
            <param name="calledRuleStack">
            A set used for preventing left recursion in the
            ATN from causing a stack overflow. Outside code should pass
            <code>new BitSet()</code>
            for this argument.
            </param>
            <param name="seeThruPreds">
            
            <code>true</code>
            to true semantic predicates as
            implicitly
            <code>true</code>
            and "see through them", otherwise
            <code>false</code>
            to treat semantic predicates as opaque and add
            <see cref="F:Antlr4.Runtime.Atn.LL1Analyzer.HitPred"/>
            to the
            result if one is encountered.
            </param>
            <param name="addEOF">
            Add
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            to the result if the end of the
            outermost context is reached. This parameter has no effect if
            <code>ctx</code>
            is
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EmptyLocal"/>
            .
            </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LookaheadEventInfo">
            <summary>
            This class represents profiling event information for tracking the lookahead
            depth required in order to make a prediction.
            </summary>
            <remarks>
            This class represents profiling event information for tracking the lookahead
            depth required in order to make a prediction.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LookaheadEventInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.LookaheadEventInfo"/>
            class with
            the specified detailed lookahead information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state containing the necessary
            information to determine the result of a prediction, or
            <code>null</code>
            if
            the final state is not available
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">The index at which the prediction was finally made</param>
            <param name="fullCtx">
            
            <code>true</code>
            if the current lookahead is part of an LL
            prediction; otherwise,
            <code>false</code>
            if the current lookahead is part of
            an SLL prediction
            </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LoopEndState">
            <summary>Mark the end of a * or + loop.</summary>
            <remarks>Mark the end of a * or + loop.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SetTransition">
            <summary>A transition containing a set of values.</summary>
            <remarks>A transition containing a set of values.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.OrderedATNConfigSet">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ParseInfo">
            <summary>
            This class provides access to specific and aggregate statistics gathered
            during profiling of a parser.
            </summary>
            <remarks>
            This class provides access to specific and aggregate statistics gathered
            during profiling of a parser.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetLLDecisions">
            <summary>
            Gets the decision numbers for decisions that required one or more
            full-context predictions during parsing.
            </summary>
            <remarks>
            Gets the decision numbers for decisions that required one or more
            full-context predictions during parsing. These are decisions for which
            <see cref="!:DecisionInfo.LL_Fallback"/>
            is non-zero.
            </remarks>
            <returns>
            A list of decision numbers which required one or more
            full-context predictions during parsing.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalTimeInPrediction">
            <summary>
            Gets the total time spent during prediction across all decisions made
            during parsing.
            </summary>
            <remarks>
            Gets the total time spent during prediction across all decisions made
            during parsing. This value is the sum of
            <see cref="!:DecisionInfo.timeInPrediction"/>
            for all decisions.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalSLLLookaheadOps">
            <summary>
            Gets the total number of SLL lookahead operations across all decisions
            made during parsing.
            </summary>
            <remarks>
            Gets the total number of SLL lookahead operations across all decisions
            made during parsing. This value is the sum of
            <see cref="!:DecisionInfo.SLL_TotalLook"/>
            for all decisions.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalLLLookaheadOps">
            <summary>
            Gets the total number of LL lookahead operations across all decisions
            made during parsing.
            </summary>
            <remarks>
            Gets the total number of LL lookahead operations across all decisions
            made during parsing. This value is the sum of
            <see cref="!:DecisionInfo.LL_TotalLook"/>
            for all decisions.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalSLLATNLookaheadOps">
            <summary>
            Gets the total number of ATN lookahead operations for SLL prediction
            across all decisions made during parsing.
            </summary>
            <remarks>
            Gets the total number of ATN lookahead operations for SLL prediction
            across all decisions made during parsing.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalLLATNLookaheadOps">
            <summary>
            Gets the total number of ATN lookahead operations for LL prediction
            across all decisions made during parsing.
            </summary>
            <remarks>
            Gets the total number of ATN lookahead operations for LL prediction
            across all decisions made during parsing.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalATNLookaheadOps">
            <summary>
            Gets the total number of ATN lookahead operations for SLL and LL
            prediction across all decisions made during parsing.
            </summary>
            <remarks>
            Gets the total number of ATN lookahead operations for SLL and LL
            prediction across all decisions made during parsing.
            <p>
            This value is the sum of
            <see cref="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalSLLATNLookaheadOps"/>
            and
            <see cref="M:Antlr4.Runtime.Atn.ParseInfo.GetTotalLLATNLookaheadOps"/>
            .</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetDFASize">
            <summary>
            Gets the total number of DFA states stored in the DFA cache for all
            decisions in the ATN.
            </summary>
            <remarks>
            Gets the total number of DFA states stored in the DFA cache for all
            decisions in the ATN.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.GetDFASize(System.Int32)">
            <summary>
            Gets the total number of DFA states stored in the DFA cache for a
            particular decision.
            </summary>
            <remarks>
            Gets the total number of DFA states stored in the DFA cache for a
            particular decision.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ParseInfo.DecisionInfo">
            <summary>
            Gets an array of
            <see cref="P:Antlr4.Runtime.Atn.ParseInfo.DecisionInfo"/>
            instances containing the profiling
            information gathered for each decision in the ATN.
            </summary>
            <returns>
            An array of
            <see cref="P:Antlr4.Runtime.Atn.ParseInfo.DecisionInfo"/>
            instances, indexed by decision
            number.
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ParserATNSimulator">
            <summary>The embodiment of the adaptive LL(*), ALL(*), parsing strategy.</summary>
            <remarks>
            The embodiment of the adaptive LL(*), ALL(*), parsing strategy.
            <p>
            The basic complexity of the adaptive strategy makes it harder to understand.
            We begin with ATN simulation to build paths in a DFA. Subsequent prediction
            requests go through the DFA first. If they reach a state without an edge for
            the current symbol, the algorithm fails over to the ATN simulation to
            complete the DFA path for the current input (until it finds a conflict state
            or uniquely predicting state).</p>
            <p>
            All of that is done without using the outer context because we want to create
            a DFA that is not dependent upon the rule invocation stack when we do a
            prediction. One DFA works in all contexts. We avoid using context not
            necessarily because it's slower, although it can be, but because of the DFA
            caching problem. The closure routine only considers the rule invocation stack
            created during prediction beginning in the decision rule. For example, if
            prediction occurs without invoking another rule's ATN, there are no context
            stacks in the configurations. When lack of context leads to a conflict, we
            don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
            strategy (versus full LL(*)).</p>
            <p>
            When SLL yields a configuration set with conflict, we rewind the input and
            retry the ATN simulation, this time using full outer context without adding
            to the DFA. Configuration context stacks will be the full invocation stacks
            from the start rule. If we get a conflict using full context, then we can
            definitively say we have a true ambiguity for that input sequence. If we
            don't get a conflict, it implies that the decision is sensitive to the outer
            context. (It is not context-sensitive in the sense of context-sensitive
            grammars.)</p>
            <p>
            The next time we reach this DFA state with an SLL conflict, through DFA
            simulation, we will again retry the ATN simulation using full context mode.
            This is slow because we can't save the results and have to "interpret" the
            ATN each time we get that input.</p>
            <p>
            <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>
            <p>
            We could cache results from full context to predicted alternative easily and
            that saves a lot of time but doesn't work in presence of predicates. The set
            of visible predicates from the ATN start state changes depending on the
            context, because closure can fall off the end of a rule. I tried to cache
            tuples (stack context, semantic context, predicted alt) but it was slower
            than interpreting and much more complicated. Also required a huge amount of
            memory. The goal is not to create the world's fastest parser anyway. I'd like
            to keep this algorithm simple. By launching multiple threads, we can improve
            the speed of parsing across a large number of files.</p>
            <p>
            There is no strict ordering between the amount of input used by SLL vs LL,
            which makes it really hard to build a cache for full context. Let's say that
            we have input A B C that leads to an SLL conflict with full context X. That
            implies that using X we might only use A B but we could also use A B C D to
            resolve conflict. Input A B C D could predict alternative 1 in one position
            in the input and A B C E could predict alternative 2 in another position in
            input. The conflicting SLL configurations could still be non-unique in the
            full context prediction, which would lead us to requiring more input than the
            original A B C.	To make a	prediction cache work, we have to track	the exact
            input	used during the previous prediction. That amounts to a cache that maps
            X to a specific DFA for that context.</p>
            <p>
            Something should be done for left-recursive expression predictions. They are
            likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
            with full LL thing Sam does.</p>
            <p>
            <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>
            <p>
            We avoid doing full context retry when the outer context is empty, we did not
            dip into the outer context by falling off the end of the decision state rule,
            or when we force SLL mode.</p>
            <p>
            As an example of the not dip into outer context case, consider as super
            constructor calls versus function calls. One grammar might look like
            this:</p>
            <pre>
            ctorBody
            : '{' superCall? stat* '}'
            ;
            </pre>
            <p>
            Or, you might see something like</p>
            <pre>
            stat
            : superCall ';'
            | expression ';'
            | ...
            ;
            </pre>
            <p>
            In both cases I believe that no closure operations will dip into the outer
            context. In the first case ctorBody in the worst case will stop at the '}'.
            In the 2nd case it should stop at the ';'. Both cases should stay within the
            entry rule and not dip into the outer context.</p>
            <p>
            <strong>PREDICATES</strong></p>
            <p>
            Predicates are always evaluated if present in either SLL or LL both. SLL and
            LL simulation deals with predicates differently. SLL collects predicates as
            it performs closure operations like ANTLR v3 did. It delays predicate
            evaluation until it reaches and accept state. This allows us to cache the SLL
            ATN simulation whereas, if we had evaluated predicates on-the-fly during
            closure, the DFA state configuration sets would be different and we couldn't
            build up a suitable DFA.</p>
            <p>
            When building a DFA accept state during ATN simulation, we evaluate any
            predicates and return the sole semantically valid alternative. If there is
            more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
            we throw an exception. Alternatives without predicates act like they have
            true predicates. The simple way to think about it is to strip away all
            alternatives with false predicates and choose the minimum alternative that
            remains.</p>
            <p>
            When we start in the DFA and reach an accept state that's predicated, we test
            those and return the minimum semantically viable alternative. If no
            alternatives are viable, we throw an exception.</p>
            <p>
            During full LL ATN simulation, closure always evaluates predicates and
            on-the-fly. This is crucial to reducing the configuration set size during
            closure. It hits a landmine when parsing with the Java grammar, for example,
            without this on-the-fly evaluation.</p>
            <p>
            <strong>SHARING DFA</strong></p>
            <p>
            All instances of the same parser share the same decision DFAs through a
            static field. Each instance gets its own ATN simulator but they share the
            same
            <see cref="F:Antlr4.Runtime.Atn.ATN.decisionToDFA"/>
            field. They also share a
            <see cref="T:Antlr4.Runtime.Atn.PredictionContextCache"/>
            object that makes sure that all
            <see cref="T:Antlr4.Runtime.Atn.PredictionContext"/>
            objects are shared among the DFA states. This makes
            a big size difference.</p>
            <p>
            <strong>THREAD SAFETY</strong></p>
            <p>
            The
            <see cref="T:Antlr4.Runtime.Atn.ParserATNSimulator"/>
            locks on the
            <see cref="F:Antlr4.Runtime.Atn.ATN.decisionToDFA"/>
            field when
            it adds a new DFA object to that array.
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAEdge(Antlr4.Runtime.Dfa.DFAState,System.Int32,Antlr4.Runtime.Dfa.DFAState)"/>
            locks on the DFA for the current decision when setting the
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.edges"/>
            field.
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.PredictionContextCache)"/>
            locks on
            the DFA for the current decision when looking up a DFA state to see if it
            already exists. We must make sure that all requests to add DFA states that
            are equivalent result in the same shared DFA object. This is because lots of
            threads will be trying to update the DFA at once. The
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.PredictionContextCache)"/>
            method also locks inside the DFA lock
            but this time on the shared context cache when it rebuilds the
            configurations'
            <see cref="T:Antlr4.Runtime.Atn.PredictionContext"/>
            objects using cached
            subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
            safe as long as we can guarantee that all threads referencing
            <code>s.edge[t]</code>
            get the same physical target
            <see cref="T:Antlr4.Runtime.Dfa.DFAState"/>
            , or
            <code>null</code>
            . Once into the DFA, the DFA simulation does not reference the
            <see cref="F:Antlr4.Runtime.Dfa.DFA.states"/>
            map. It follows the
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.edges"/>
            field to new
            targets. The DFA simulator will either find
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.edges"/>
            to be
            <code>null</code>
            , to be non-
            <code>null</code>
            and
            <code>dfa.edges[t]</code>
            null, or
            <code>dfa.edges[t]</code>
            to be non-null. The
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAEdge(Antlr4.Runtime.Dfa.DFAState,System.Int32,Antlr4.Runtime.Dfa.DFAState)"/>
            method could be racing to set the field
            but in either case the DFA simulator works; if
            <code>null</code>
            , and requests ATN
            simulation. It could also race trying to get
            <code>dfa.edges[t]</code>
            , but either
            way it will work because it's not doing a test and set operation.</p>
            <p>
            <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage
            Parsing)</strong></p>
            <p>
            Sam pointed out that if SLL does not give a syntax error, then there is no
            point in doing full LL, which is slower. We only have to try LL if we get a
            syntax error. For maximum speed, Sam starts the parser set to pure SLL
            mode with the
            <see cref="T:Antlr4.Runtime.BailErrorStrategy"/>
            :</p>
            <pre>
            parser.
            <see cref="P:Antlr4.Runtime.Recognizer`2.Interpreter">getInterpreter()</see>
            .
            <see cref="P:Antlr4.Runtime.Atn.ParserATNSimulator.PredictionMode"/>
            <code>(</code>
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Sll"/>
            <code>)</code>
            ;
            parser.
            <see cref="!:Parser.ErrorHandler"/>
            (new
            <see cref="T:Antlr4.Runtime.BailErrorStrategy"/>
            ());
            </pre>
            <p>
            If it does not get a syntax error, then we're done. If it does get a syntax
            error, we need to retry with the combined SLL/LL strategy.</p>
            <p>
            The reason this works is as follows. If there are no SLL conflicts, then the
            grammar is SLL (at least for that input set). If there is an SLL conflict,
            the full LL analysis must yield a set of viable alternatives which is a
            subset of the alternatives reported by SLL. If the LL set is a singleton,
            then the grammar is LL but not SLL. If the LL set is the same size as the SLL
            set, the decision is SLL. If the LL set has size &gt; 1, then that decision
            is truly ambiguous on the current input. If the LL set is smaller, then the
            SLL conflict resolution might choose an alternative that the full LL would
            rule out as a possibility based upon better context information. If that's
            the case, then the SLL parse will definitely get an error because the full LL
            analysis says it's not viable. If SLL conflict resolution chooses an
            alternative within the LL set, them both SLL and LL would choose the same
            alternative because they both choose the minimum of multiple conflicting
            alternatives.</p>
            <p>
            Let's say we have a set of SLL conflicting alternatives
            <code/>
            
            1, 2, 3}} and
            a smaller LL set called <em>s</em>. If <em>s</em> is
            <code/>
            
            2, 3}}, then SLL
            parsing will get an error because SLL will pursue alternative 1. If
            <em>s</em> is
            <code/>
            
            1, 2}} or
            <code/>
            
            1, 3}} then both SLL and LL will
            choose the same alternative because alternative one is the minimum of either
            set. If <em>s</em> is
            <code/>
            
            2}} or
            <code/>
            
            3}} then SLL will get a syntax
            error. If <em>s</em> is
            <code/>
            
            1}} then SLL will succeed.</p>
            <p>
            Of course, if the input is invalid, then we will get an error for sure in
            both SLL and LL parsing. Erroneous input will therefore require 2 passes over
            the input.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ParserATNSimulator.enable_global_context_dfa">
            <summary>Determines whether the DFA is used for full-context predictions.</summary>
            <remarks>
            Determines whether the DFA is used for full-context predictions. When
            <code>true</code>
            , the DFA stores transition information for both full-context
            and SLL parsing; otherwise, the DFA only stores SLL transition
            information.
            <p>
            For some grammars, enabling the full-context DFA can result in a
            substantial performance improvement. However, this improvement typically
            comes at the expense of memory used for storing the cached DFA states,
            configuration sets, and prediction contexts.</p>
            <p>
            The default value is
            <code>false</code>
            .</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ParserATNSimulator.reportAmbiguities">
            <summary>
            When
            <code>true</code>
            , ambiguous alternatives are reported when they are
            encountered within
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ExecATN(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
            . When
            <code>false</code>
            , these messages
            are suppressed. The default is
            <code>false</code>
            .
            <p/>
            When messages about ambiguous alternatives are not required, setting this
            to
            <code>false</code>
            enables additional internal optimizations which may lose
            this information.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ParserATNSimulator.userWantsCtxSensitive">
            <summary>
            By default we do full context-sensitive LL(*) parsing not
            Strong LL(*) parsing.
            </summary>
            <remarks>
            By default we do full context-sensitive LL(*) parsing not
            Strong LL(*) parsing. If we fail with Strong LL(*) we
            try full LL(*). That means we rewind and use context information
            when closure operations fall off the end of the rule that
            holds the decision were evaluating.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.#ctor(Antlr4.Runtime.Atn.ATN)">
            <summary>Testing only!</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ExecATN(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            Performs ATN simulation to compute a predicted alternative based
            upon the remaining input, but also updates the DFA cache to avoid
            having to traverse the ATN again for the same input sequence.
            </summary>
            <remarks>
            Performs ATN simulation to compute a predicted alternative based
            upon the remaining input, but also updates the DFA cache to avoid
            having to traverse the ATN again for the same input sequence.
            There are some key conditions we're looking for after computing a new
            set of ATN configs (proposed DFA state):
            if the set is empty, there is no viable alternative for current symbol
            does the state uniquely predict an alternative?
            does the state have a conflict that would prevent us from
            putting it on the work list?
            if in non-greedy decision is there a config at a rule stop state?
            We also have some key operations to do:
            add an edge from previous DFA state to potentially new DFA state, D,
            upon current symbol but only if adding to work list, which means in all
            cases except no viable alternative (and possibly non-greedy decisions?)
            collecting predicates and adding semantic context to DFA accept states
            adding rule context to context-sensitive DFA accept states
            consuming an input symbol
            reporting a conflict
            reporting an ambiguity
            reporting a context sensitivity
            reporting insufficient predicates
            We should isolate those operations, which are side-effecting, to the
            main work loop. We can isolate lots of code into other functions, but
            they should be side effect free. They can return package that
            indicates whether we should report something, whether we need to add a
            DFA edge, whether we need to augment accept state with semantic
            context or rule invocation context. Actually, it seems like we always
            add predicates if they exist, so that can simply be done in the main
            loop for any accept state creation or modification request.
            cover these cases:
            dead end
            single alt
            single alt + preds
            conflict
            conflict + preds
            TODO: greedy + those
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.HandleNoViableAlt(Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            This method is used to improve the localization of error messages by
            choosing an alternative rather than throwing a
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            in particular prediction scenarios where the
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.Error"/>
            state was reached during ATN simulation.
            <p>
            The default implementation of this method uses the following
            algorithm to identify an ATN configuration which successfully parsed the
            decision entry rule. Choosing such an alternative ensures that the
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            returned by the calling rule will be complete
            and valid, and the syntax error will be reported later at a more
            localized location.</p>
            <ul>
            <li>If no configuration in
            <code>configs</code>
            reached the end of the
            decision rule, return
            <see cref="F:Antlr4.Runtime.Atn.ATN.InvalidAltNumber"/>
            .</li>
            <li>If all configurations in
            <code>configs</code>
            which reached the end of the
            decision rule predict the same alternative, return that alternative.</li>
            <li>If the configurations in
            <code>configs</code>
            which reached the end of the
            decision rule predict multiple alternatives (call this <em>S</em>),
            choose an alternative in the following order.
            <ol>
            <li>Filter the configurations in
            <code>configs</code>
            to only those
            configurations which remain viable after evaluating semantic predicates.
            If the set of these filtered configurations which also reached the end of
            the decision rule is not empty, return the minimum alternative
            represented in this set.</li>
            <li>Otherwise, choose the minimum alternative in <em>S</em>.</li>
            </ol>
            </li>
            </ul>
            <p>
            In some scenarios, the algorithm described above could predict an
            alternative which will result in a
            <see cref="T:Antlr4.Runtime.FailedPredicateException"/>
            in
            parser. Specifically, this could occur if the <em>only</em> configuration
            capable of successfully parsing to the end of the decision rule is
            blocked by a semantic predicate. By choosing this alternative within
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AdaptivePredict(Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.ParserRuleContext)"/>
            instead of throwing a
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            , the resulting
            <see cref="T:Antlr4.Runtime.FailedPredicateException"/>
            in the parser will identify the specific
            predicate which is preventing the parser from successfully parsing the
            decision rule, which helps developers identify and correct logic errors
            in semantic predicates.
            </p>
            </summary>
            <param name="input">
            The input
            <see cref="T:Antlr4.Runtime.ITokenStream"/>
            </param>
            <param name="startIndex">
            The start index for the current prediction, which is
            the input index where any semantic context in
            <code>configs</code>
            should be
            evaluated
            </param>
            <param name="previous">
            The ATN simulation state immediately before the
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.Error"/>
            state was reached
            </param>
            <returns>
            The value to return from
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AdaptivePredict(Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.ParserRuleContext)"/>
            , or
            <see cref="F:Antlr4.Runtime.Atn.ATN.InvalidAltNumber"/>
            if a suitable alternative was not
            identified and
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AdaptivePredict(Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.ParserRuleContext)"/>
            should report an error instead.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)">
            <summary>Get an existing target state for an edge in the DFA.</summary>
            <remarks>
            Get an existing target state for an edge in the DFA. If the target state
            for the edge has not yet been computed or is otherwise not available,
            this method returns
            <code>null</code>
            .
            </remarks>
            <param name="s">The current DFA state</param>
            <param name="t">The next input symbol</param>
            <returns>
            The existing target DFA state for the given input symbol
            <code>t</code>
            , or
            <code>null</code>
            if the target state for this edge is not
            already cached
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ComputeTargetState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.ParserRuleContext,System.Int32,System.Boolean,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>
            Compute a target state for an edge in the DFA, and attempt to add the
            computed state and corresponding edge to the DFA.
            </summary>
            <remarks>
            Compute a target state for an edge in the DFA, and attempt to add the
            computed state and corresponding edge to the DFA.
            </remarks>
            <param name="dfa"/>
            <param name="s">The current DFA state</param>
            <param name="remainingGlobalContext"/>
            <param name="t">The next input symbol</param>
            <param name="useContext"/>
            <param name="contextCache"/>
            <returns>
            The computed target DFA state for the given input symbol
            <code>t</code>
            . If
            <code>t</code>
            does not lead to a valid DFA state, this method
            returns
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.Error"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.RemoveAllConfigsNotInRuleStopState(Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>
            Return a configuration set containing only the configurations from
            <code>configs</code>
            which are in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            . If all
            configurations in
            <code>configs</code>
            are already in a rule stop state, this
            method simply returns
            <code>configs</code>
            .
            </summary>
            <param name="configs">the configuration set to update</param>
            <param name="contextCache">
            the
            <see cref="T:Antlr4.Runtime.Atn.PredictionContext"/>
            cache
            </param>
            <returns>
            
            <code>configs</code>
            if all configurations in
            <code>configs</code>
            are in a
            rule stop state, otherwise return a new configuration set containing only
            the configurations from
            <code>configs</code>
            which are in a rule stop state
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ApplyPrecedenceFilter(Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.ParserRuleContext,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>
            This method transforms the start state computed by
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ComputeStartState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.ParserRuleContext,System.Boolean)"/>
            to the special start state used by a
            precedence DFA for a particular precedence value. The transformation
            process applies the following changes to the start state's configuration
            set.
            <ol>
            <li>Evaluate the precedence predicates for each configuration using
            <see cref="M:Antlr4.Runtime.Atn.SemanticContext.EvalPrecedence``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)"/>
            .</li>
            <li>Remove all configurations which predict an alternative greater than
            1, for which another configuration that predicts alternative 1 is in the
            same ATN state with the same prediction context. This transformation is
            valid for the following reasons:
            <ul>
            <li>The closure block cannot contain any epsilon transitions which bypass
            the body of the closure, so all states reachable via alternative 1 are
            part of the precedence alternatives of the transformed left-recursive
            rule.</li>
            <li>The "primary" portion of a left recursive rule cannot contain an
            epsilon transition, so the only way an alternative other than 1 can exist
            in a state that is also reachable via alternative 1 is by nesting calls
            to the left-recursive rule, with the outer calls not being at the
            preferred precedence level.</li>
            </ul>
            </li>
            </ol>
            <p>
            The prediction context must be considered by this filter to address
            situations like the following.
            </p>
            <code>
            <pre>
            grammar TA;
            prog: statement* EOF;
            statement: letterA | statement letterA 'b' ;
            letterA: 'a';
            </pre>
            </code>
            <p>
            If the above grammar, the ATN state immediately before the token
            reference
            <code>'a'</code>
            in
            <code>letterA</code>
            is reachable from the left edge
            of both the primary and closure blocks of the left-recursive rule
            <code>statement</code>
            . The prediction context associated with each of these
            configurations distinguishes between them, and prevents the alternative
            which stepped out to
            <code>prog</code>
            (and then back in to
            <code>statement</code>
            from being eliminated by the filter.
            </p>
            </summary>
            <param name="configs">
            The configuration set computed by
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ComputeStartState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.ParserRuleContext,System.Boolean)"/>
            as the start state for the DFA.
            </param>
            <returns>
            The transformed configuration set representing the start state
            for a precedence DFA at a particular precedence level (determined by
            calling
            <see cref="P:Antlr4.Runtime.Parser.Precedence"/>
            ).
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.PredicateDFAState(Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)">
            <summary>collect and set D's semantic context</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Dfa.DFAState.PredPrediction[],Antlr4.Runtime.ParserRuleContext,System.Boolean)">
            <summary>
            Look through a list of predicate/alt pairs, returning alts for the
            pairs that win.
            </summary>
            <remarks>
            Look through a list of predicate/alt pairs, returning alts for the
            pairs that win. A
            <code>null</code>
            predicate indicates an alt containing an
            unpredicated config which behaves as "always true."
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Atn.SemanticContext,Antlr4.Runtime.ParserRuleContext,System.Int32)">
            <summary>Evaluate a semantic context within a specific parser context.</summary>
            <remarks>
            Evaluate a semantic context within a specific parser context.
            <p>
            This method might not be called for every semantic context evaluated
            during the prediction process. In particular, we currently do not
            evaluate the following but it may change in the future:</p>
            <ul>
            <li>Precedence predicates (represented by
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.PrecedencePredicate"/>
            ) are not currently evaluated
            through this method.</li>
            <li>Operator predicates (represented by
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.AND"/>
            and
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.OR"/>
            ) are evaluated as a single semantic
            context, rather than evaluating the operands individually.
            Implementations which require evaluation results from individual
            predicates should override this method to explicitly handle evaluation of
            the operands within operator predicates.</li>
            </ul>
            </remarks>
            <param name="pred">The semantic context to evaluate</param>
            <param name="parserCallStack">
            The parser context in which to evaluate the
            semantic context
            </param>
            <param name="alt">
            The alternative which is guarded by
            <code>pred</code>
            </param>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAContextState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>See comment on LexerInterpreter.addDFAState.</summary>
            <remarks>See comment on LexerInterpreter.addDFAState.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.PredictionContextCache)">
            <summary>See comment on LexerInterpreter.addDFAState.</summary>
            <remarks>See comment on LexerInterpreter.addDFAState.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ReportAmbiguity(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>If context sensitive parsing, we know it's ambiguity not conflict</summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ParserATNSimulator.Parser">
            <since>4.3</since>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PlusBlockStartState">
            <summary>
            Start of
            <code>(A|B|...)+</code>
            loop. Technically a decision state, but
            we don't use for code generation; somebody might need it, so I'm defining
            it for completeness. In reality, the
            <see cref="T:Antlr4.Runtime.Atn.PlusLoopbackState"/>
            node is the
            real decision-making note for
            <code>A+</code>
            .
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PlusLoopbackState">
            <summary>
            Decision state for
            <code>A+</code>
            and
            <code>(A|B)+</code>
            .  It has two transitions:
            one to the loop back to start of the block and one to exit.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PrecedencePredicateTransition">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredicateEvalInfo">
            <summary>
            This class represents profiling event information for semantic predicate
            evaluations which occur during prediction.
            </summary>
            <remarks>
            This class represents profiling event information for semantic predicate
            evaluations which occur during prediction.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Dfa.DFAState.PredPrediction[],Antlr4.Runtime.ParserRuleContext,System.Boolean)"/>
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredicateEvalInfo.semctx">
            <summary>The semantic context which was evaluated.</summary>
            <remarks>The semantic context which was evaluated.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredicateEvalInfo.predictedAlt">
            <summary>
            The alternative number for the decision which is guarded by the semantic
            context
            <see cref="F:Antlr4.Runtime.Atn.PredicateEvalInfo.semctx"/>
            . Note that other ATN
            configurations may predict the same alternative which are guarded by
            other semantic contexts and/or
            <see cref="F:Antlr4.Runtime.Atn.SemanticContext.None"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredicateEvalInfo.evalResult">
            <summary>
            The result of evaluating the semantic context
            <see cref="F:Antlr4.Runtime.Atn.PredicateEvalInfo.semctx"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredicateEvalInfo.#ctor(Antlr4.Runtime.Atn.SimulatorState,System.Int32,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32,Antlr4.Runtime.Atn.SemanticContext,System.Boolean,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.PredicateEvalInfo"/>
            class with the
            specified detailed predicate evaluation information.
            </summary>
            <param name="state">The simulator state</param>
            <param name="decision">The decision number</param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">
            The index at which the predicate evaluation was
            triggered. Note that the input stream may be reset to other positions for
            the actual evaluation of individual predicates.
            </param>
            <param name="semctx">The semantic context which was evaluated</param>
            <param name="evalResult">The results of evaluating the semantic context</param>
            <param name="predictedAlt">
            The alternative number for the decision which is
            guarded by the semantic context
            <code>semctx</code>
            . See
            <see cref="F:Antlr4.Runtime.Atn.PredicateEvalInfo.predictedAlt"/>
            for more information.
            </param>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Atn.SemanticContext,Antlr4.Runtime.ParserRuleContext,System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Atn.SemanticContext.Eval``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)"/>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredicateTransition">
            <summary>
            TODO: this is old comment:
            A tree of semantic predicates from the grammar AST if label==SEMPRED.
            </summary>
            <remarks>
            TODO: this is old comment:
            A tree of semantic predicates from the grammar AST if label==SEMPRED.
            In the ATN, labels will always be exactly one predicate, but the DFA
            may have to combine a bunch of them as it collects predicates from
            multiple ATN configurations into a single DFA state.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredictionContextCache">
            <summary>
            Used to cache
            <see cref="T:Antlr4.Runtime.Atn.PredictionContext"/>
            objects. Its used for the shared
            context cash associated with contexts in DFA states. This cache
            can be used for both lexers and parsers.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredictionMode">
            <summary>
            This enumeration defines the prediction modes available in ANTLR 4 along with
            utility methods for analyzing configuration sets for conflicts and/or
            ambiguities.
            </summary>
            <remarks>
            This enumeration defines the prediction modes available in ANTLR 4 along with
            utility methods for analyzing configuration sets for conflicts and/or
            ambiguities.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.Sll">
            <summary>The SLL(*) prediction mode.</summary>
            <remarks>
            The SLL(*) prediction mode. This prediction mode ignores the current
            parser context when making predictions. This is the fastest prediction
            mode, and provides correct results for many grammars. This prediction
            mode is more powerful than the prediction mode provided by ANTLR 3, but
            may result in syntax errors for grammar and input combinations which are
            not SLL.
            <p>
            When using this prediction mode, the parser will either return a correct
            parse tree (i.e. the same parse tree that would be returned with the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            prediction mode), or it will report a syntax error. If a
            syntax error is encountered when using the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Sll"/>
            prediction mode,
            it may be due to either an actual syntax error in the input or indicate
            that the particular combination of grammar and input requires the more
            powerful
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            prediction abilities to complete successfully.</p>
            <p>
            This prediction mode does not provide any guarantees for prediction
            behavior for syntactically-incorrect inputs.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.Ll">
            <summary>The LL(*) prediction mode.</summary>
            <remarks>
            The LL(*) prediction mode. This prediction mode allows the current parser
            context to be used for resolving SLL conflicts that occur during
            prediction. This is the fastest prediction mode that guarantees correct
            parse results for all combinations of grammars with syntactically correct
            inputs.
            <p>
            When using this prediction mode, the parser will make correct decisions
            for all syntactically-correct grammar and input combinations. However, in
            cases where the grammar is truly ambiguous this prediction mode might not
            report a precise answer for <em>exactly which</em> alternatives are
            ambiguous.</p>
            <p>
            This prediction mode does not provide any guarantees for prediction
            behavior for syntactically-incorrect inputs.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection">
            <summary>The LL(*) prediction mode with exact ambiguity detection.</summary>
            <remarks>
            The LL(*) prediction mode with exact ambiguity detection. In addition to
            the correctness guarantees provided by the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.Ll"/>
            prediction mode,
            this prediction mode instructs the prediction algorithm to determine the
            complete and exact set of ambiguous alternatives for every ambiguous
            decision encountered while parsing.
            <p>
            This prediction mode may be used for diagnosing ambiguities during
            grammar development. Due to the performance overhead of calculating sets
            of ambiguous alternatives, this prediction mode should be avoided when
            the exact results are not necessary.</p>
            <p>
            This prediction mode does not provide any guarantees for prediction
            behavior for syntactically-incorrect inputs.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasSLLConflictTerminatingPrediction(Antlr4.Runtime.Atn.PredictionMode,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>Computes the SLL prediction termination condition.</summary>
            <remarks>
            Computes the SLL prediction termination condition.
            <p>
            This method computes the SLL prediction termination condition for both of
            the following cases.</p>
            <ul>
            <li>The usual SLL+LL fallback upon SLL conflict</li>
            <li>Pure SLL without LL fallback</li>
            </ul>
            <p><strong>COMBINED SLL+LL PARSING</strong></p>
            <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
            ensured regardless of how the termination condition is computed by this
            method. Due to the substantially higher cost of LL prediction, the
            prediction should only fall back to LL when the additional lookahead
            cannot lead to a unique SLL prediction.</p>
            <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
            conflicting subsets should fall back to full LL, even if the
            configuration sets don't resolve to the same alternative (e.g.
            <code/>
            
            1,2}} and
            <code/>
            
            3,4}}. If there is at least one non-conflicting
            configuration, SLL could continue with the hopes that more lookahead will
            resolve via one of those non-conflicting configurations.</p>
            <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
            stops when it sees only conflicting configuration subsets. In contrast,
            full LL keeps going when there is uncertainty.</p>
            <p><strong>HEURISTIC</strong></p>
            <p>As a heuristic, we stop prediction when we see any conflicting subset
            unless we see a state that only has one alternative associated with it.
            The single-alt-state thing lets prediction continue upon rules like
            (otherwise, it would admit defeat too soon):</p>
            <p>
            <code>[12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;</code>
            </p>
            <p>When the ATN simulation reaches the state before
            <code>';'</code>
            , it has a
            DFA state that looks like:
            <code>[12|1|[], 6|2|[], 12|2|[]]</code>
            . Naturally
            <code>12|1|[]</code>
            and
            <code>12|2|[]</code>
            conflict, but we cannot stop
            processing this node because alternative to has another way to continue,
            via
            <code>[6|2|[]]</code>
            .</p>
            <p>It also let's us continue for this rule:</p>
            <p>
            <code>[1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;</code>
            </p>
            <p>After matching input A, we reach the stop state for rule A, state 1.
            State 8 is the state right before B. Clearly alternatives 1 and 2
            conflict and no amount of further lookahead will separate the two.
            However, alternative 3 will be able to continue and so we do not stop
            working on this state. In the previous example, we're concerned with
            states associated with the conflicting alternatives. Here alt 3 is not
            associated with the conflicting configs, but since we can continue
            looking for input reasonably, don't declare the state done.</p>
            <p><strong>PURE SLL PARSING</strong></p>
            <p>To handle pure SLL parsing, all we have to do is make sure that we
            combine stack contexts for configurations that differ only by semantic
            predicate. From there, we can do the usual SLL termination heuristic.</p>
            <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
            <p>SLL decisions don't evaluate predicates until after they reach DFA stop
            states because they need to create the DFA cache that works in all
            semantic situations. In contrast, full LL evaluates predicates collected
            during start state computation so it can ignore predicates thereafter.
            This means that SLL termination detection can totally ignore semantic
            predicates.</p>
            <p>Implementation-wise,
            <see cref="T:Antlr4.Runtime.Atn.ATNConfigSet"/>
            combines stack contexts but not
            semantic predicate contexts so we might see two configurations like the
            following.</p>
            <p>
            <code/>
            (s, 1, x,
            ), (s, 1, x', {p})}</p>
            <p>Before testing these configurations against others, we have to merge
            <code>x</code>
            and
            <code>x'</code>
            (without modifying the existing configurations).
            For example, we test
            <code>(x+x')==x''</code>
            when looking for conflicts in
            the following configurations.</p>
            <p>
            <code/>
            (s, 1, x,
            ), (s, 1, x', {p}), (s, 2, x'', {})}</p>
            <p>If the configuration set has predicates (as indicated by
            <see cref="P:Antlr4.Runtime.Atn.ATNConfigSet.HasSemanticContext"/>
            ), this algorithm makes a copy of
            the configurations to strip out all of the predicates so that a standard
            <see cref="T:Antlr4.Runtime.Atn.ATNConfigSet"/>
            will merge everything ignoring predicates.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasConfigInRuleStopState(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>
            Checks if any configuration in
            <code>configs</code>
            is in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            . Configurations meeting this condition have reached
            the end of the decision rule (local context) or end of start rule (full
            context).
            </summary>
            <param name="configs">the configuration set to test</param>
            <returns>
            
            <code>true</code>
            if any configuration in
            <code>configs</code>
            is in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            , otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllConfigsInRuleStopStates(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>
            Checks if all configurations in
            <code>configs</code>
            are in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            . Configurations meeting this condition have reached
            the end of the decision rule (local context) or end of start rule (full
            context).
            </summary>
            <param name="configs">the configuration set to test</param>
            <returns>
            
            <code>true</code>
            if all configurations in
            <code>configs</code>
            are in a
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            , otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.ResolvesToJustOneViableAlt(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>Full LL prediction termination.</summary>
            <remarks>
            Full LL prediction termination.
            <p>Can we stop looking ahead during ATN simulation or is there some
            uncertainty as to which alternative we will ultimately pick, after
            consuming more input? Even if there are partial conflicts, we might know
            that everything is going to resolve to the same minimum alternative. That
            means we can stop since no more lookahead will change that fact. On the
            other hand, there might be multiple conflicts that resolve to different
            minimums. That means we need more look ahead to decide which of those
            alternatives we should predict.</p>
            <p>The basic idea is to split the set of configurations
            <code>C</code>
            , into
            conflicting subsets
            <code>(s, _, ctx, _)</code>
            and singleton subsets with
            non-conflicting configurations. Two configurations conflict if they have
            identical
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.State"/>
            and
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Context"/>
            values
            but different
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Alt"/>
            value, e.g.
            <code>(s, i, ctx, _)</code>
            and
            <code>(s, j, ctx, _)</code>
            for
            <code>i!=j</code>
            .</p>
            <p/>
            Reduce these configuration subsets to the set of possible alternatives.
            You can compute the alternative subsets in one pass as follows:
            <p/>
            <code/>
            A_s,ctx =
            i | (s, i, ctx, _)}} for each configuration in
            <code>C</code>
            holding
            <code>s</code>
            and
            <code>ctx</code>
            fixed.
            <p/>
            Or in pseudo-code, for each configuration
            <code>c</code>
            in
            <code>C</code>
            :
            <pre>
            map[c] U= c.
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Alt">getAlt()</see>
            # map hash/equals uses s and x, not
            alt and not pred
            </pre>
            <p>The values in
            <code>map</code>
            are the set of
            <code>A_s,ctx</code>
            sets.</p>
            <p>If
            <code>|A_s,ctx|=1</code>
            then there is no conflict associated with
            <code>s</code>
            and
            <code>ctx</code>
            .</p>
            <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
            the union of these alternative subsets is a singleton, then no amount of
            more lookahead will help us. We will always pick that alternative. If,
            however, there is more than one alternative, then we are uncertain which
            alternative to predict and must continue looking for resolution. We may
            or may not discover an ambiguity in the future, even if there are no
            conflicting subsets this round.</p>
            <p>The biggest sin is to terminate early because it means we've made a
            decision but were uncertain as to the eventual outcome. We haven't used
            enough lookahead. On the other hand, announcing a conflict too late is no
            big deal; you will still have the conflict. It's just inefficient. It
            might even look until the end of file.</p>
            <p>No special consideration for semantic predicates is required because
            predicates are evaluated on-the-fly for full LL prediction, ensuring that
            no configuration contains a semantic context during the termination
            check.</p>
            <p><strong>CONFLICTING CONFIGS</strong></p>
            <p>Two configurations
            <code>(s, i, x)</code>
            and
            <code>(s, j, x')</code>
            , conflict
            when
            <code>i!=j</code>
            but
            <code>x=x'</code>
            . Because we merge all
            <code>(s, i, _)</code>
            configurations together, that means that there are at
            most
            <code>n</code>
            configurations associated with state
            <code>s</code>
            for
            <code>n</code>
            possible alternatives in the decision. The merged stacks
            complicate the comparison of configuration contexts
            <code>x</code>
            and
            <code>x'</code>
            . Sam checks to see if one is a subset of the other by calling
            merge and checking to see if the merged result is either
            <code>x</code>
            or
            <code>x'</code>
            . If the
            <code>x</code>
            associated with lowest alternative
            <code>i</code>
            is the superset, then
            <code>i</code>
            is the only possible prediction since the
            others resolve to
            <code>min(i)</code>
            as well. However, if
            <code>x</code>
            is
            associated with
            <code>j&gt;i</code>
            then at least one stack configuration for
            <code>j</code>
            is not in conflict with alternative
            <code>i</code>
            . The algorithm
            should keep going, looking for more lookahead due to the uncertainty.</p>
            <p>For simplicity, I'm doing a equality check between
            <code>x</code>
            and
            <code>x'</code>
            that lets the algorithm continue to consume lookahead longer
            than necessary. The reason I like the equality is of course the
            simplicity but also because that is the test you need to detect the
            alternatives that are actually in conflict.</p>
            <p><strong>CONTINUE/STOP RULE</strong></p>
            <p>Continue if union of resolved alternative sets from non-conflicting and
            conflicting alternative subsets has more than one alternative. We are
            uncertain about which alternative to predict.</p>
            <p>The complete set of alternatives,
            <code>[i for (_,i,_)]</code>
            , tells us which
            alternatives are still in the running for the amount of input we've
            consumed at this point. The conflicting sets let us to strip away
            configurations that won't lead to more states because we resolve
            conflicts to the configuration with a minimum alternate for the
            conflicting set.</p>
            <p><strong>CASES</strong></p>
            <ul>
            <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
            <li>
            <code>(s, 1, x)</code>
            ,
            <code>(s, 2, x)</code>
            ,
            <code>(s, 3, z)</code>
            ,
            <code>(s', 1, y)</code>
            ,
            <code>(s', 2, y)</code>
            yields non-conflicting set
            <code/>
            
            3}} U conflicting sets
            <code/>
            min(
            1,2})} U
            <code/>
            min(
            1,2})} =
            <code/>
            
            1,3}} =&gt; continue
            </li>
            <li>
            <code>(s, 1, x)</code>
            ,
            <code>(s, 2, x)</code>
            ,
            <code>(s', 1, y)</code>
            ,
            <code>(s', 2, y)</code>
            ,
            <code>(s'', 1, z)</code>
            yields non-conflicting set
            <code/>
            
            1}} U conflicting sets
            <code/>
            min(
            1,2})} U
            <code/>
            min(
            1,2})} =
            <code/>
            
            1}} =&gt; stop and predict 1</li>
            <li>
            <code>(s, 1, x)</code>
            ,
            <code>(s, 2, x)</code>
            ,
            <code>(s', 1, y)</code>
            ,
            <code>(s', 2, y)</code>
            yields conflicting, reduced sets
            <code/>
            
            1}} U
            <code/>
            
            1}} =
            <code/>
            
            1}} =&gt; stop and predict 1, can announce
            ambiguity
            <code/>
            
            1,2}}</li>
            <li>
            <code>(s, 1, x)</code>
            ,
            <code>(s, 2, x)</code>
            ,
            <code>(s', 2, y)</code>
            ,
            <code>(s', 3, y)</code>
            yields conflicting, reduced sets
            <code/>
            
            1}} U
            <code/>
            
            2}} =
            <code/>
            
            1,2}} =&gt; continue</li>
            <li>
            <code>(s, 1, x)</code>
            ,
            <code>(s, 2, x)</code>
            ,
            <code>(s', 3, y)</code>
            ,
            <code>(s', 4, y)</code>
            yields conflicting, reduced sets
            <code/>
            
            1}} U
            <code/>
            
            3}} =
            <code/>
            
            1,3}} =&gt; continue</li>
            </ul>
            <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
            <p>If all states report the same conflicting set of alternatives, then we
            know we have the exact ambiguity set.</p>
            <p><code>|A_<em>i</em>|&gt;1</code> and
            <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
            <p>In other words, we continue examining lookahead until all
            <code>A_i</code>
            have more than one alternative and all
            <code>A_i</code>
            are the same. If
            <code/>
            A=
            {1,2}, {1,3}}}, then regular LL prediction would terminate
            because the resolved set is
            <code/>
            
            1}}. To determine what the real
            ambiguity is, we have to know whether the ambiguity is between one and
            two or one and three so we keep going. We can only stop prediction when
            we need exact ambiguity detection when the sets look like
            <code/>
            A=
            {1,2}}} or
            <code/>
            
            {1,2},{1,2}}}, etc...</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllSubsetsConflict(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Determines if every alternative subset in
            <code>altsets</code>
            contains more
            than one alternative.
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>
            
            <code>true</code>
            if every
            <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
            in
            <code>altsets</code>
            has
            <see cref="M:Antlr4.Runtime.Sharpen.BitSet.Cardinality">cardinality</see>
            &gt; 1, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasNonConflictingAltSet(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Determines if any single alternative subset in
            <code>altsets</code>
            contains
            exactly one alternative.
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>
            
            <code>true</code>
            if
            <code>altsets</code>
            contains a
            <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
            with
            <see cref="M:Antlr4.Runtime.Sharpen.BitSet.Cardinality">cardinality</see>
            1, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasConflictingAltSet(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Determines if any single alternative subset in
            <code>altsets</code>
            contains
            more than one alternative.
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>
            
            <code>true</code>
            if
            <code>altsets</code>
            contains a
            <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
            with
            <see cref="M:Antlr4.Runtime.Sharpen.BitSet.Cardinality">cardinality</see>
            &gt; 1, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllSubsetsEqual(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Determines if every alternative subset in
            <code>altsets</code>
            is equivalent.
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>
            
            <code>true</code>
            if every member of
            <code>altsets</code>
            is equal to the
            others, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetUniqueAlt(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Returns the unique alternative predicted by all alternative subsets in
            <code>altsets</code>
            . If no such alternative exists, this method returns
            <see cref="F:Antlr4.Runtime.Atn.ATN.InvalidAltNumber"/>
            .
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetAlts(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Gets the complete set of represented alternatives for a collection of
            alternative subsets.
            </summary>
            <remarks>
            Gets the complete set of represented alternatives for a collection of
            alternative subsets. This method returns the union of each
            <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
            in
            <code>altsets</code>
            .
            </remarks>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>
            the set of represented alternatives in
            <code>altsets</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetConflictingAltSubsets(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>This function gets the conflicting alt subsets from a configuration set.</summary>
            <remarks>
            This function gets the conflicting alt subsets from a configuration set.
            For each configuration
            <code>c</code>
            in
            <code>configs</code>
            :
            <pre>
            map[c] U= c.
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Alt">getAlt()</see>
            # map hash/equals uses s and x, not
            alt and not pred
            </pre>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetStateToAltMap(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>Get a map from state to alt subset from a configuration set.</summary>
            <remarks>
            Get a map from state to alt subset from a configuration set. For each
            configuration
            <code>c</code>
            in
            <code>configs</code>
            :
            <pre>
            map[c.
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.State"/>
            ] U= c.
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Alt"/>
            </pre>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredictionMode.AltAndContextMap">
            <summary>A Map that uses just the state and the stack context as the key.</summary>
            <remarks>A Map that uses just the state and the stack context as the key.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AltAndContextConfigEqualityComparator.GetHashCode(Antlr4.Runtime.Atn.ATNConfig)">
            <summary>
            The hash code is only a function of the
            <see cref="F:Antlr4.Runtime.Atn.ATNState.stateNumber"/>
            and
            <see cref="P:Antlr4.Runtime.Atn.ATNConfig.Context"/>
            .
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ProfilingATNSimulator">
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ProfilingATNSimulator.conflictingAltResolvedBySLL">
            <summary>
            At the point of LL failover, we record how SLL would resolve the conflict so that
            we can determine whether or not a decision / input pair is context-sensitive.
            </summary>
            <remarks>
            At the point of LL failover, we record how SLL would resolve the conflict so that
            we can determine whether or not a decision / input pair is context-sensitive.
            If LL gives a different result than SLL's predicted alternative, we have a
            context sensitivity for sure. The converse is not necessarily true, however.
            It's possible that after conflict resolution chooses minimum alternatives,
            SLL could get the same answer as LL. Regardless of whether or not the result indicates
            an ambiguity, it is not treated as a context sensitivity because LL prediction
            was not required in order to produce a correct prediction for this decision and input sequence.
            It may in fact still be a context sensitivity but we don't know by looking at the
            minimum alternatives for the current input.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.RuleStopState">
            <summary>The last node in the ATN for a rule, unless that rule is the start symbol.</summary>
            <remarks>
            The last node in the ATN for a rule, unless that rule is the start symbol.
            In that case, there is one transition to EOF. Later, we might encode
            references to all calls to this rule to compute FOLLOW sets for
            error handling.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.RuleTransition.ruleIndex">
            <summary>Ptr to the rule definition object for this rule ref</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.RuleTransition.followState">
            <summary>What node to begin computations following ref to rule</summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SemanticContext">
            <summary>
            A tree structure used to record the semantic context in which
            an ATN configuration is valid.
            </summary>
            <remarks>
            A tree structure used to record the semantic context in which
            an ATN configuration is valid.  It's either a single predicate,
            a conjunction
            <code>p1&amp;&amp;p2</code>
            , or a sum of products
            <code>p1||p2</code>
            .
            <p>I have scoped the
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.AND"/>
            ,
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.OR"/>
            , and
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext.Predicate"/>
            subclasses of
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext"/>
            within the scope of this outer class.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.SemanticContext.None">
            <summary>
            The default
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext"/>
            , which is semantically equivalent to
            a predicate of the form
            <code/>
            
            true}?}.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.SemanticContext.Eval``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)">
            <summary>
            For context independent predicates, we evaluate them without a local
            context (i.e., null context).
            </summary>
            <remarks>
            For context independent predicates, we evaluate them without a local
            context (i.e., null context). That way, we can evaluate them without
            having to create proper rule-specific context during prediction (as
            opposed to the parser, which creates them naturally). In a practical
            sense, this avoids a cast exception from RuleContext to myruleContext.
            <p>For context dependent predicates, we must pass in a local context so that
            references such as $arg evaluate properly as _localctx.arg. We only
            capture context dependent predicates in the context in which we begin
            prediction, so we passed in the outer context here in case of context
            dependent predicate evaluation.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.SemanticContext.EvalPrecedence``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)">
            <summary>Evaluate the precedence predicates for the context and reduce the result.</summary>
            <remarks>Evaluate the precedence predicates for the context and reduce the result.</remarks>
            <param name="parser">The parser instance.</param>
            <param name="parserCallStack"/>
            <returns>
            The simplified semantic context after precedence predicates are
            evaluated, which will be one of the following values.
            <ul>
            <li>
            <see cref="F:Antlr4.Runtime.Atn.SemanticContext.None"/>
            : if the predicate simplifies to
            <code>true</code>
            after
            precedence predicates are evaluated.</li>
            <li>
            <code>null</code>
            : if the predicate simplifies to
            <code>false</code>
            after
            precedence predicates are evaluated.</li>
            <li>
            <code>this</code>
            : if the semantic context is not changed as a result of
            precedence predicate evaluation.</li>
            <li>A non-
            <code>null</code>
            
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext"/>
            : the new simplified
            semantic context after precedence predicates are evaluated.</li>
            </ul>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.SemanticContext.Or(Antlr4.Runtime.Atn.SemanticContext,Antlr4.Runtime.Atn.SemanticContext)">
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetPredsForAmbigAlts(Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)"/>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SemanticContext.Operator">
            <summary>
            This is the base class for semantic context "operators", which operate on
            a collection of semantic context "operands".
            </summary>
            <remarks>
            This is the base class for semantic context "operators", which operate on
            a collection of semantic context "operands".
            </remarks>
            <since>4.3</since>
        </member>
        <member name="P:Antlr4.Runtime.Atn.SemanticContext.Operator.Operands">
            <summary>Gets the operands for the semantic context operator.</summary>
            <remarks>Gets the operands for the semantic context operator.</remarks>
            <returns>
            a collection of
            <see cref="T:Antlr4.Runtime.Atn.SemanticContext"/>
            operands for the
            operator.
            </returns>
            <since>4.3</since>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SemanticContext.AND">
            <summary>
            A semantic context which is true whenever none of the contained contexts
            is false.
            </summary>
            <remarks>
            A semantic context which is true whenever none of the contained contexts
            is false.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.SemanticContext.AND.Eval``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)">
            <summary>
            <inheritDoc/>
            <p>
            The evaluation of predicates by this context is short-circuiting, but
            unordered.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SemanticContext.OR">
            <summary>
            A semantic context which is true whenever at least one of the contained
            contexts is true.
            </summary>
            <remarks>
            A semantic context which is true whenever at least one of the contained
            contexts is true.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.SemanticContext.OR.Eval``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)">
            <summary>
            <inheritDoc/>
            <p>
            The evaluation of predicates by this context is short-circuiting, but
            unordered.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SimulatorState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.StarBlockStartState">
            <summary>The block that begins a closure loop.</summary>
            <remarks>The block that begins a closure loop.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.StarLoopEntryState.precedenceRuleDecision">
            <summary>
            Indicates whether this state can benefit from a precedence DFA during SLL
            decision making.
            </summary>
            <remarks>
            Indicates whether this state can benefit from a precedence DFA during SLL
            decision making.
            <p>This is a computed property that is calculated during ATN deserialization
            and stored for use in
            <see cref="T:Antlr4.Runtime.Atn.ParserATNSimulator"/>
            and
            <see cref="T:Antlr4.Runtime.ParserInterpreter"/>
            .</p>
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa"/>
        </member>
        <member name="T:Antlr4.Runtime.Atn.TokensStartState">
            <summary>The Tokens rule start state linking to each lexer rule start state</summary>
        </member>
        <member name="T:Antlr4.Runtime.BailErrorStrategy">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy"/>
            responds to syntax errors
            by immediately canceling the parse operation with a
            <see cref="T:Antlr4.Runtime.Misc.ParseCanceledException"/>
            . The implementation ensures that the
            <see cref="F:Antlr4.Runtime.ParserRuleContext.exception"/>
            field is set for all parse tree nodes
            that were not completed prior to encountering the error.
            <p>
            This error strategy is useful in the following scenarios.</p>
            <ul>
            <li><strong>Two-stage parsing:</strong> This error strategy allows the first
            stage of two-stage parsing to immediately terminate if an error is
            encountered, and immediately fall back to the second stage. In addition to
            avoiding wasted work by attempting to recover from errors here, the empty
            implementation of
            <see cref="M:Antlr4.Runtime.BailErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            improves the performance of
            the first stage.</li>
            <li><strong>Silent validation:</strong> When syntax errors are not being
            reported or logged, and the parse result is simply ignored if errors occur,
            the
            <see cref="T:Antlr4.Runtime.BailErrorStrategy"/>
            avoids wasting work on recovering from errors
            when the result will be ignored either way.</li>
            </ul>
            <p>
            <code>myparser.setErrorHandler(new BailErrorStrategy());</code>
            </p>
            </summary>
            <seealso cref="P:Antlr4.Runtime.Parser.ErrorHandler"/>
        </member>
        <member name="T:Antlr4.Runtime.DefaultErrorStrategy">
            <summary>
            This is the default implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy"/>
            used for
            error reporting and recovery in ANTLR parsers.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.IAntlrErrorStrategy">
            <summary>
            The interface for defining strategies to deal with syntax errors encountered
            during a parse by ANTLR-generated parsers.
            </summary>
            <remarks>
            The interface for defining strategies to deal with syntax errors encountered
            during a parse by ANTLR-generated parsers. We distinguish between three
            different kinds of errors:
            <ul>
            <li>The parser could not figure out which path to take in the ATN (none of
            the available alternatives could possibly match)</li>
            <li>The current input does not match what we were looking for</li>
            <li>A predicate evaluated to false</li>
            </ul>
            Implementations of this interface report syntax errors by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            .
            <p>TODO: what to do about lexers</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Reset(Antlr4.Runtime.Parser)">
            <summary>
            Reset the error handler state for the specified
            <code>recognizer</code>
            .
            </summary>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            This method is called when an unexpected symbol is encountered during an
            inline match operation, such as
            <see cref="M:Antlr4.Runtime.Parser.Match(System.Int32)"/>
            . If the error
            strategy successfully recovers from the match failure, this method
            returns the
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance which should be treated as the
            successful result of the match.
            <p>Note that the calling code will not report an error if this method
            returns successfully. The error strategy implementation is responsible
            for calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            as appropriate.</p>
            </summary>
            <param name="recognizer">the parser instance</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the error strategy was not able to
            recover from the unexpected input symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            This method is called to recover from exception
            <code>e</code>
            . This method is
            called after
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            by the default exception handler
            generated for a rule method.
            </summary>
            <seealso cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception to recover from</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the error strategy could not recover from
            the recognition exception
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>
            This method provides the error handler with an opportunity to handle
            syntactic or semantic errors in the input stream before they result in a
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            .
            <p>The generated code currently contains calls to
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            after
            entering the decision state of a closure block (
            <code>(...)*</code>
            or
            <code>(...)+</code>
            ).</p>
            <p>For an implementation based on Jim Idle's "magic sync" mechanism, see
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            .</p>
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            <param name="recognizer">the parser instance</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if an error is detected by the error
            strategy but cannot be automatically recovered at the current state in
            the parsing process
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)">
            <summary>
            Tests whether or not
            <code>recognizer</code>
            is in the process of recovering
            from an error. In error recovery mode,
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            adds
            symbols to the parse tree by calling
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            instead of
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.IToken)"/>
            .
            </summary>
            <param name="recognizer">the parser instance</param>
            <returns>
            
            <code>true</code>
            if the parser is currently recovering from a parse
            error, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)">
            <summary>
            This method is called by when the parser successfully matches an input
            symbol.
            </summary>
            <remarks>
            This method is called by when the parser successfully matches an input
            symbol.
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            Report any kind of
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            . This method is called by
            the default exception handler generated for a rule method.
            </summary>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception to report</param>
        </member>
        <member name="F:Antlr4.Runtime.DefaultErrorStrategy.errorRecoveryMode">
            <summary>
            Indicates whether the error strategy is currently "recovering from an
            error".
            </summary>
            <remarks>
            Indicates whether the error strategy is currently "recovering from an
            error". This is used to suppress reporting multiple error messages while
            attempting to recover from a detected syntax error.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)"/>
        </member>
        <member name="F:Antlr4.Runtime.DefaultErrorStrategy.lastErrorIndex">
            <summary>The index into the input stream where the last error occurred.</summary>
            <remarks>
            The index into the input stream where the last error occurred.
            This is used to prevent infinite loops where an error is found
            but no token is consumed during recovery...another error is found,
            ad nauseum.  This is a failsafe mechanism to guarantee that at least
            one token/tree node is consumed for two errors.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Reset(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc/>
            <p>The default implementation simply calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)"/>
            to
            ensure that the handler is not in error recovery mode.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to enter error recovery mode when a recognition
            exception is reported.
            </summary>
            <remarks>
            This method is called to enter error recovery mode when a recognition
            exception is reported.
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to leave error recovery mode after recovering from
            a recognition exception.
            </summary>
            <remarks>
            This method is called to leave error recovery mode after recovering from
            a recognition exception.
            </remarks>
            <param name="recognizer"/>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc/>
            <p>The default implementation simply calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)"/>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc/>
            <p>The default implementation returns immediately if the handler is already
            in error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)"/>
            and dispatches the reporting task based on the runtime type of
            <code>e</code>
            according to the following table.</p>
            <ul>
            <li>
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportNoViableAlternative(Antlr4.Runtime.Parser,Antlr4.Runtime.NoViableAltException)"/>
            </li>
            <li>
            <see cref="T:Antlr4.Runtime.InputMismatchException"/>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportInputMismatch(Antlr4.Runtime.Parser,Antlr4.Runtime.InputMismatchException)"/>
            </li>
            <li>
            <see cref="T:Antlr4.Runtime.FailedPredicateException"/>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportFailedPredicate(Antlr4.Runtime.Parser,Antlr4.Runtime.FailedPredicateException)"/>
            </li>
            <li>All other types: calls
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            to report
            the exception</li>
            </ul>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc/>
            <p>The default implementation resynchronizes the parser by consuming tokens
            until we find one in the resynchronization set--loosely the set of tokens
            that can follow the current rule.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>
            The default implementation of
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            makes sure
            that the current lookahead symbol is consistent with what were expecting
            at this point in the ATN. You can call this anytime but ANTLR only
            generates code to check before subrules/loops and each iteration.
            <p>Implements Jim Idle's magic sync mechanism in closures and optional
            subrules. E.g.,</p>
            <pre>
            a : sync ( stuff sync )* ;
            sync : {consume to what can follow sync} ;
            </pre>
            At the start of a sub rule upon error,
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            performs single
            token deletion, if possible. If it can't do that, it bails on the current
            rule and uses the default error recovery, which consumes until the
            resynchronization set of the current rule.
            <p>If the sub rule is optional (
            <code>(...)?</code>
            ,
            <code>(...)*</code>
            , or block
            with an empty alternative), then the expected set includes what follows
            the subrule.</p>
            <p>During loop iteration, it consumes until it sees a token that can start a
            sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
            stay in the loop as long as possible.</p>
            <p><strong>ORIGINS</strong></p>
            <p>Previous versions of ANTLR did a poor job of their recovery within loops.
            A single mismatch token or missing token would force the parser to bail
            out of the entire rules surrounding the loop. So, for rule</p>
            <pre>
            classDef : 'class' ID '{' member* '}'
            </pre>
            input with an extra token between members would force the parser to
            consume until it found the next class definition rather than the next
            member definition of the current class.
            <p>This functionality cost a little bit of effort because the parser has to
            compare token set at the start of the loop and at each iteration. If for
            some reason speed is suffering for you, you can turn off this
            functionality by simply overriding this method as a blank { }.</p>
            </summary>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportNoViableAlternative(Antlr4.Runtime.Parser,Antlr4.Runtime.NoViableAltException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            when the exception is a
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportInputMismatch(Antlr4.Runtime.Parser,Antlr4.Runtime.InputMismatchException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            when the exception is an
            <see cref="T:Antlr4.Runtime.InputMismatchException"/>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportFailedPredicate(Antlr4.Runtime.Parser,Antlr4.Runtime.FailedPredicateException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            when the exception is a
            <see cref="T:Antlr4.Runtime.FailedPredicateException"/>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportUnwantedToken(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to report a syntax error which requires the removal
            of a token from the input stream.
            </summary>
            <remarks>
            This method is called to report a syntax error which requires the removal
            of a token from the input stream. At the time this method is called, the
            erroneous symbol is current
            <code>LT(1)</code>
            symbol and has not yet been
            removed from the input stream. When this method returns,
            <code>recognizer</code>
            is in error recovery mode.
            <p>This method is called when
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)"/>
            identifies
            single-token deletion as a viable recovery strategy for a mismatched
            input error.</p>
            <p>The default implementation simply returns if the handler is already in
            error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)"/>
            to
            enter error recovery mode, followed by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMissingToken(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to report a syntax error which requires the
            insertion of a missing token into the input stream.
            </summary>
            <remarks>
            This method is called to report a syntax error which requires the
            insertion of a missing token into the input stream. At the time this
            method is called, the missing token has not yet been inserted. When this
            method returns,
            <code>recognizer</code>
            is in error recovery mode.
            <p>This method is called when
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)"/>
            identifies
            single-token insertion as a viable recovery strategy for a mismatched
            input error.</p>
            <p>The default implementation simply returns if the handler is already in
            error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)"/>
            to
            enter error recovery mode, followed by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc/>
            <p>The default implementation attempts to recover from the mismatched input
            by using single token insertion and deletion as described below. If the
            recovery attempt fails, this method throws an
            <see cref="T:Antlr4.Runtime.InputMismatchException"/>
            .</p>
            <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
            <p>
            <code>LA(1)</code>
            is not what we are looking for. If
            <code>LA(2)</code>
            has the
            right token, however, then assume
            <code>LA(1)</code>
            is some extra spurious
            token and delete it. Then consume and return the next token (which was
            the
            <code>LA(2)</code>
            token) as the successful result of the match operation.</p>
            <p>This recovery strategy is implemented by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)"/>
            .</p>
            <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
            <p>If current token (at
            <code>LA(1)</code>
            ) is consistent with what could come
            after the expected
            <code>LA(1)</code>
            token, then assume the token is missing
            and use the parser's
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            to create it on the fly. The
            "insertion" is performed by returning the created token as the successful
            result of the match operation.</p>
            <p>This recovery strategy is implemented by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)"/>
            .</p>
            <p><strong>EXAMPLE</strong></p>
            <p>For example, Input
            <code>i=(3;</code>
            is clearly missing the
            <code>')'</code>
            . When
            the parser returns from the nested call to
            <code>expr</code>
            , it will have
            call chain:</p>
            <pre>
            stat â expr â atom
            </pre>
            and it will be trying to match the
            <code>')'</code>
            at this point in the
            derivation:
            <pre>
            =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
            ^
            </pre>
            The attempt to match
            <code>')'</code>
            will fail when it sees
            <code>';'</code>
            and
            call
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            . To recover, it sees that
            <code>LA(1)==';'</code>
            is in the set of tokens that can follow the
            <code>')'</code>
            token reference
            in rule
            <code>atom</code>
            . It can assume that you forgot the
            <code>')'</code>
            .
            </summary>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)">
            <summary>
            This method implements the single-token insertion inline error recovery
            strategy.
            </summary>
            <remarks>
            This method implements the single-token insertion inline error recovery
            strategy. It is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            if the single-token
            deletion strategy fails to recover from the mismatched input. If this
            method returns
            <code>true</code>
            ,
            <code>recognizer</code>
            will be in error recovery
            mode.
            <p>This method determines whether or not single-token insertion is viable by
            checking if the
            <code>LA(1)</code>
            input symbol could be successfully matched
            if it were instead the
            <code>LA(2)</code>
            symbol. If this method returns
            <code>true</code>
            , the caller is responsible for creating and inserting a
            token with the correct type to produce this behavior.</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <returns>
            
            <code>true</code>
            if single-token insertion is a viable recovery
            strategy for the current mismatched input, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)">
            <summary>
            This method implements the single-token deletion inline error recovery
            strategy.
            </summary>
            <remarks>
            This method implements the single-token deletion inline error recovery
            strategy. It is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            to attempt to recover
            from mismatched input. If this method returns null, the parser and error
            handler state will not have changed. If this method returns non-null,
            <code>recognizer</code>
            will <em>not</em> be in error recovery mode since the
            returned token was a successful match.
            <p>If the single-token deletion is successful, this method calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportUnwantedToken(Antlr4.Runtime.Parser)"/>
            to report the error, followed by
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            to actually "delete" the extraneous token. Then,
            before returning
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)"/>
            is called to signal a successful
            match.</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <returns>
            the successfully matched
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance if single-token
            deletion successfully recovers from the mismatched input, otherwise
            <code>null</code>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.GetMissingSymbol(Antlr4.Runtime.Parser)">
            <summary>Conjure up a missing token during error recovery.</summary>
            <remarks>
            Conjure up a missing token during error recovery.
            The recognizer attempts to recover from single missing
            symbols. But, actions might refer to that missing symbol.
            For example, x=ID {f($x);}. The action clearly assumes
            that there has been an identifier matched previously and that
            $x points at that token. If that token is missing, but
            the next token in the stream is what we want we assume that
            this token is missing and we keep going. Because we
            have to return some token to replace the missing token,
            we have to conjure one up. This method gives the user control
            over the tokens returned for missing tokens. Mostly,
            you will want to create something special for identifier
            tokens. For literals such as '{' and ',', the default
            action in the parser or tree parser works. It simply creates
            a CommonToken of the appropriate type. The text will be the token.
            If you change what tokens must be created by the lexer,
            override this method to create the appropriate tokens.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.GetTokenErrorDisplay(Antlr4.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.
            </summary>
            <remarks>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.toString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new Java type.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ConsumeUntil(Antlr4.Runtime.Parser,Antlr4.Runtime.Misc.IntervalSet)">
            <summary>Consume tokens until one matches the given token set.</summary>
            <remarks>Consume tokens until one matches the given token set.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            Instead of recovering from exception
            <code>e</code>
            , re-throw it wrapped
            in a
            <see cref="T:Antlr4.Runtime.Misc.ParseCanceledException"/>
            so it is not caught by the
            rule function catches.  Use
            <see cref="P:System.Exception.InnerException"/>
            to get the
            original
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            Make sure we don't attempt to recover inline; if the parser
            successfully recovers, it won't throw an exception.
            </summary>
            <remarks>
            Make sure we don't attempt to recover inline; if the parser
            successfully recovers, it won't throw an exception.
            </remarks>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>Make sure we don't attempt to recover from problems in subrules.</summary>
            <remarks>Make sure we don't attempt to recover from problems in subrules.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.BaseErrorListener">
            <summary>
            Provides an empty default implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            . The
            default implementation of each method does nothing, but can be overridden as
            necessary.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.IParserErrorListener">
            <summary>How to emit recognition errors for parsers.</summary>
            <remarks>How to emit recognition errors for parsers.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.IAntlrErrorListener`1">
            <summary>How to emit recognition errors.</summary>
            <remarks>How to emit recognition errors.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorListener`1.SyntaxError(Antlr4.Runtime.IRecognizer,`0,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)">
            <summary>Upon syntax error, notify any interested parties.</summary>
            <remarks>
            Upon syntax error, notify any interested parties. This is not how to
            recover from errors or compute error messages.
            <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy"/>
            specifies how to recover from syntax errors and how to compute error
            messages. This listener's job is simply to emit a computed message,
            though it has enough information to create its own message in many cases.
            <p>The
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            is non-null for all syntax errors except
            when we discover mismatched token errors that we can recover from
            in-line, without returning from the surrounding rule (via the single
            token insertion and deletion mechanism).</p>
            </remarks>
            <param name="recognizer">
            What parser got the error. From this
            object, you can access the context as well
            as the input stream.
            </param>
            <param name="offendingSymbol">
            The offending token in the input token
            stream, unless recognizer is a lexer (then it's null). If
            no viable alternative error,
            <code>e</code>
            has token at which we
            started production for the decision.
            </param>
            <param name="line">The line number in the input where the error occurred.</param>
            <param name="charPositionInLine">The character position within that line where the error occurred.</param>
            <param name="msg">The message to emit.</param>
            <param name="e">
            The exception generated by the parser that led to
            the reporting of an error. It is null in the case where
            the parser was able to recover in line without exiting the
            surrounding rule.
            </param>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>
            This method is called by the parser when a full-context prediction
            results in an ambiguity.
            </summary>
            <remarks>
            This method is called by the parser when a full-context prediction
            results in an ambiguity.
            <p>Each full-context prediction which does not result in a syntax error
            will call either
            <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
            or
            <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            .</p>
            <p>
            When
            <code>ambigAlts</code>
            is not null, it contains the set of potentially
            viable alternatives identified by the prediction algorithm. When
            <code>ambigAlts</code>
            is null, use
            <see cref="P:Antlr4.Runtime.Atn.ATNConfigSet.RepresentedAlternatives"/>
            to obtain the represented
            alternatives from the
            <code>configs</code>
            argument.</p>
            <p>When
            <code>exact</code>
            is
            <code>true</code>
            , <em>all</em> of the potentially
            viable alternatives are truly viable, i.e. this is reporting an exact
            ambiguity. When
            <code>exact</code>
            is
            <code>false</code>
            , <em>at least two</em> of
            the potentially viable alternatives are viable for the current input, but
            the prediction algorithm terminated as soon as it determined that at
            least the <em>minimum</em> potentially viable alternative is truly
            viable.</p>
            <p>When the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection"/>
            prediction
            mode is used, the parser is required to identify exact ambiguities so
            <code>exact</code>
            will always be
            <code>true</code>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <param name="dfa">the DFA for the current decision</param>
            <param name="startIndex">the input index where the decision started</param>
            <param name="stopIndex">the input input where the ambiguity was identified</param>
            <param name="exact">
            
            <code>true</code>
            if the ambiguity is exactly known, otherwise
            <code>false</code>
            . This is always
            <code>true</code>
            when
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LlExactAmbigDetection"/>
            is used.
            </param>
            <param name="ambigAlts">
            the potentially ambiguous alternatives, or
            <code>null</code>
            to indicate that the potentially ambiguous alternatives are the complete
            set of represented alternatives in
            <code>configs</code>
            </param>
            <param name="configs">
            the ATN configuration set where the ambiguity was
            identified
            </param>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportAttemptingFullContext(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            This method is called when an SLL conflict occurs and the parser is about
            to use the full context information to make an LL decision.
            </summary>
            <remarks>
            This method is called when an SLL conflict occurs and the parser is about
            to use the full context information to make an LL decision.
            <p>If one or more configurations in
            <code>configs</code>
            contains a semantic
            predicate, the predicates are evaluated before this method is called. The
            subset of alternatives which are still viable after predicates are
            evaluated is reported in
            <code>conflictingAlts</code>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <param name="dfa">the DFA for the current decision</param>
            <param name="startIndex">the input index where the decision started</param>
            <param name="stopIndex">the input index where the SLL conflict occurred</param>
            <param name="conflictingAlts">
            The specific conflicting alternatives. If this is
            <code>null</code>
            , the conflicting alternatives are all alternatives
            represented in
            <code>configs</code>
            .
            </param>
            <param name="conflictState">
            the simulator state when the SLL conflict was
            detected
            </param>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            This method is called by the parser when a full-context prediction has a
            unique result.
            </summary>
            <remarks>
            This method is called by the parser when a full-context prediction has a
            unique result.
            <p>Each full-context prediction which does not result in a syntax error
            will call either
            <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
            or
            <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            .</p>
            <p>For prediction implementations that only evaluate full-context
            predictions when an SLL conflict is found (including the default
            <see cref="T:Antlr4.Runtime.Atn.ParserATNSimulator"/>
            implementation), this method reports cases
            where SLL conflicts were resolved to unique full-context predictions,
            i.e. the decision was context-sensitive. This report does not necessarily
            indicate a problem, and it may appear even in completely unambiguous
            grammars.</p>
            <p>
            <code>configs</code>
            may have more than one represented alternative if the
            full-context prediction algorithm does not evaluate predicates before
            beginning the full-context prediction. In all cases, the final prediction
            is passed as the
            <code>prediction</code>
            argument.</p>
            <p>Note that the definition of "context sensitivity" in this method
            differs from the concept in
            <see cref="F:Antlr4.Runtime.Atn.DecisionInfo.contextSensitivities"/>
            .
            This method reports all instances where an SLL conflict occurred but LL
            parsing produced a unique result, whether or not that unique result
            matches the minimum alternative in the SLL conflicting set.</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <param name="dfa">the DFA for the current decision</param>
            <param name="startIndex">the input index where the decision started</param>
            <param name="stopIndex">
            the input index where the context sensitivity was
            finally determined
            </param>
            <param name="prediction">the unambiguous result of the full-context prediction</param>
            <param name="acceptState">
            the simulator state when the unambiguous prediction
            was determined
            </param>
        </member>
        <member name="T:Antlr4.Runtime.BufferedTokenStream">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.ITokenStream"/>
            loads tokens from a
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            on-demand, and places the tokens in a buffer to provide
            access to any previous token by index.
            <p>
            This token stream ignores the value of
            <see cref="P:Antlr4.Runtime.IToken.Channel"/>
            . If your
            parser requires the token stream filter tokens to only those on a particular
            channel, such as
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            or
            <see cref="F:Antlr4.Runtime.TokenConstants.HiddenChannel"/>
            , use a filtering token stream such a
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.ITokenStream">
            <summary>
            An
            <see cref="T:Antlr4.Runtime.IIntStream"/>
            whose symbols are
            <see cref="T:Antlr4.Runtime.IToken"/>
            instances.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.Lt(System.Int32)">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance associated with the value returned by
            <see cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)">LA(k)</see>
            . This method has the same pre- and post-conditions as
            <see cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)"/>
            . In addition, when the preconditions of this method
            are met, the return value is non-null and the value of
            <code>LT(k).getType()==LA(k)</code>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.Get(System.Int32)">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.IToken"/>
            at the specified
            <code>index</code>
            in the stream. When
            the preconditions of this method are met, the return value is non-null.
            <p>The preconditions for this method are the same as the preconditions of
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
            . If the behavior of
            <code>seek(index)</code>
            is
            unspecified for the current state and given
            <code>index</code>
            , then the
            behavior of this method is also unspecified.</p>
            <p>The symbol referred to by
            <code>index</code>
            differs from
            <code>seek()</code>
            only
            in the case of filtering streams where
            <code>index</code>
            lies before the end
            of the stream. Unlike
            <code>seek()</code>
            , this method does not adjust
            <code>index</code>
            to point to a non-ignored symbol.</p>
            </summary>
            <exception cref="T:System.ArgumentException">if {code index} is less than 0</exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            retrieving the token at the specified index
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the text of all tokens within the specified
            <code>interval</code>
            . This
            method behaves like the following code (including potential exceptions
            for violating preconditions of
            <see cref="M:Antlr4.Runtime.ITokenStream.Get(System.Int32)"/>
            , but may be optimized by the
            specific implementation.
            <pre>
            TokenStream stream = ...;
            String text = "";
            for (int i = interval.a; i &lt;= interval.b; i++) {
            text += stream.get(i).getText();
            }
            </pre>
            </summary>
            <param name="interval">
            The interval of tokens within this stream to get text
            for.
            </param>
            <returns>
            The text of all tokens within the specified interval in this
            stream.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            if
            <code>interval</code>
            is
            <code>null</code>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText">
            <summary>Return the text of all tokens in the stream.</summary>
            <remarks>
            Return the text of all tokens in the stream. This method behaves like the
            following code, including potential exceptions from the calls to
            <see cref="P:Antlr4.Runtime.IIntStream.Size"/>
            and
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)"/>
            , but may be
            optimized by the specific implementation.
            <pre>
            TokenStream stream = ...;
            String text = stream.getText(new Interval(0, stream.size()));
            </pre>
            </remarks>
            <returns>The text of all tokens in the stream.</returns>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.RuleContext)">
            <summary>
            Return the text of all tokens in the source interval of the specified
            context.
            </summary>
            <remarks>
            Return the text of all tokens in the source interval of the specified
            context. This method behaves like the following code, including potential
            exceptions from the call to
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)"/>
            , but may be
            optimized by the specific implementation.
            <p>If
            <code>ctx.getSourceInterval()</code>
            does not return a valid interval of
            tokens provided by this stream, the behavior is unspecified.</p>
            <pre>
            TokenStream stream = ...;
            String text = stream.getText(ctx.getSourceInterval());
            </pre>
            </remarks>
            <param name="ctx">
            The context providing the source interval of tokens to get
            text for.
            </param>
            <returns>
            The text of all tokens within the source interval of
            <code>ctx</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.IToken,Antlr4.Runtime.IToken)">
            <summary>
            Return the text of all tokens in this stream between
            <code>start</code>
            and
            <code>stop</code>
            (inclusive).
            <p>If the specified
            <code>start</code>
            or
            <code>stop</code>
            token was not provided by
            this stream, or if the
            <code>stop</code>
            occurred before the
            <code>start</code>
            token, the behavior is unspecified.</p>
            <p>For streams which ensure that the
            <see cref="P:Antlr4.Runtime.IToken.TokenIndex"/>
            method is
            accurate for all of its provided tokens, this method behaves like the
            following code. Other streams may implement this method in other ways
            provided the behavior is consistent with this at a high level.</p>
            <pre>
            TokenStream stream = ...;
            String text = "";
            for (int i = start.getTokenIndex(); i &lt;= stop.getTokenIndex(); i++) {
            text += stream.get(i).getText();
            }
            </pre>
            </summary>
            <param name="start">The first token in the interval to get text for.</param>
            <param name="stop">The last token in the interval to get text for (inclusive).</param>
            <returns>
            The text of all tokens lying between the specified
            <code>start</code>
            and
            <code>stop</code>
            tokens.
            </returns>
            <exception cref="T:System.NotSupportedException">
            if this stream does not support
            this method for the specified tokens
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.ITokenStream.TokenSource">
            <summary>
            Gets the underlying
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            which provides tokens for this
            stream.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.tokenSource">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            from which tokens for this stream are fetched.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.tokens">
            <summary>A collection of all tokens fetched from the token source.</summary>
            <remarks>
            A collection of all tokens fetched from the token source. The list is
            considered a complete view of the input once
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.fetchedEOF"/>
            is set
            to
            <code>true</code>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.p">
            <summary>
            The index into
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            of the current token (next token to
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Consume"/>
            ).
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            <code>[</code>
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.p"/>
            <code>]</code>
            should be
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Lt(System.Int32)">LT(1)</see>
            .
            <p>This field is set to -1 when the stream is first constructed or when
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.SetTokenSource(Antlr4.Runtime.ITokenSource)"/>
            is called, indicating that the first token has
            not yet been fetched from the token source. For additional information,
            see the documentation of
            <see cref="T:Antlr4.Runtime.IIntStream"/>
            for a description of
            Initializing Methods.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.fetchedEOF">
            <summary>
            Indicates whether the
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            token has been fetched from
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokenSource"/>
            and added to
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            . This field improves
            performance for the following cases:
            <ul>
            <li>
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Consume"/>
            : The lookahead check in
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Consume"/>
            to prevent
            consuming the EOF symbol is optimized by checking the values of
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.fetchedEOF"/>
            and
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.p"/>
            instead of calling
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.La(System.Int32)"/>
            .</li>
            <li>
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Fetch(System.Int32)"/>
            : The check to prevent adding multiple EOF symbols into
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            is trivial with this field.</li>
            </ul>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Sync(System.Int32)">
            <summary>
            Make sure index
            <code>i</code>
            in tokens has a token.
            </summary>
            <returns>
            
            <code>true</code>
            if a token is located at index
            <code>i</code>
            , otherwise
            <code>false</code>
            .
            </returns>
            <seealso cref="M:Antlr4.Runtime.BufferedTokenStream.Get(System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Fetch(System.Int32)">
            <summary>
            Add
            <code>n</code>
            elements to buffer.
            </summary>
            <returns>The actual number of elements added to the buffer.</returns>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Get(System.Int32,System.Int32)">
            <summary>Get all tokens from start..stop inclusively.</summary>
            <remarks>Get all tokens from start..stop inclusively.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.AdjustSeekIndex(System.Int32)">
            <summary>
            Allowed derived classes to modify the behavior of operations which change
            the current stream position by adjusting the target token index of a seek
            operation.
            </summary>
            <remarks>
            Allowed derived classes to modify the behavior of operations which change
            the current stream position by adjusting the target token index of a seek
            operation. The default implementation simply returns
            <code>i</code>
            . If an
            exception is thrown in this method, the current stream index should not be
            changed.
            <p>For example,
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            overrides this method to ensure that
            the seek target is always an on-channel token.</p>
            </remarks>
            <param name="i">The target token index.</param>
            <returns>The adjusted target token index.</returns>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.SetTokenSource(Antlr4.Runtime.ITokenSource)">
            <summary>Reset this token stream by setting its token source.</summary>
            <remarks>Reset this token stream by setting its token source.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetTokens(System.Int32,System.Int32,Antlr4.Runtime.Sharpen.BitSet)">
            <summary>
            Given a start and stop index, return a
            <code>List</code>
            of all tokens in
            the token type
            <code>BitSet</code>
            .  Return
            <code>null</code>
            if no tokens were found.  This
            method looks at both on and off channel tokens.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.NextTokenOnChannel(System.Int32,System.Int32)">
            <summary>Given a starting index, return the index of the next token on channel.</summary>
            <remarks>
            Given a starting index, return the index of the next token on channel.
            Return
            <code>i</code>
            if
            <code>tokens[i]</code>
            is on channel. Return the index of
            the EOF token if there are no tokens on channel between
            <code>i</code>
            and
            EOF.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.PreviousTokenOnChannel(System.Int32,System.Int32)">
            <summary>
            Given a starting index, return the index of the previous token on
            channel.
            </summary>
            <remarks>
            Given a starting index, return the index of the previous token on
            channel. Return
            <code>i</code>
            if
            <code>tokens[i]</code>
            is on channel. Return -1
            if there are no tokens on channel between
            <code>i</code>
            and 0.
            <p>
            If
            <code>i</code>
            specifies an index at or after the EOF token, the EOF token
            index is returned. This is due to the fact that the EOF token is treated
            as though it were on every channel.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToRight(System.Int32,System.Int32)">
            <summary>
            Collect all tokens on specified channel to the right of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            or
            EOF. If
            <code>channel</code>
            is
            <code>-1</code>
            , find any non default channel token.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToRight(System.Int32)">
            <summary>
            Collect all hidden tokens (any off-default channel) to the right of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            or EOF.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToLeft(System.Int32,System.Int32)">
            <summary>
            Collect all tokens on specified channel to the left of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            .
            If
            <code>channel</code>
            is
            <code>-1</code>
            , find any non default channel token.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToLeft(System.Int32)">
            <summary>
            Collect all hidden tokens (any off-default channel) to the left of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetText">
            <summary>Get the text of all tokens in this buffer.</summary>
            <remarks>Get the text of all tokens in this buffer.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Fill">
            <summary>Get all tokens from lexer until EOF.</summary>
            <remarks>Get all tokens from lexer until EOF.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.IToken">
            <summary>
            A token has properties: text, type, line, character position in the line
            (so we can ignore tabs), token channel, index, and source from which
            we obtained this token.
            </summary>
            <remarks>
            A token has properties: text, type, line, character position in the line
            (so we can ignore tabs), token channel, index, and source from which
            we obtained this token.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Text">
            <summary>Get the text of the token.</summary>
            <remarks>Get the text of the token.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Type">
            <summary>Get the token type of the token.</summary>
            <remarks>Get the token type of the token.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Line">
            <summary>
            The line number on which the 1st character of this token was matched,
            line=1..n
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Column">
            <summary>
            The index of the first character of this token relative to the
            beginning of the line at which it occurs, 0..n-1
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Channel">
            <summary>Return the channel this token.</summary>
            <remarks>
            Return the channel this token. Each token can arrive at the parser
            on a different channel, but the parser only "tunes" to a single channel.
            The parser ignores everything not on DEFAULT_CHANNEL.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.TokenIndex">
            <summary>An index from 0..n-1 of the token object in the input stream.</summary>
            <remarks>
            An index from 0..n-1 of the token object in the input stream.
            This must be valid in order to print token streams and
            use TokenRewriteStream.
            Return -1 to indicate that this token was conjured up since
            it doesn't have a valid index.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.StartIndex">
            <summary>
            The starting character index of the token
            This method is optional; return -1 if not implemented.
            </summary>
            <remarks>
            The starting character index of the token
            This method is optional; return -1 if not implemented.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.StopIndex">
            <summary>The last character index of the token.</summary>
            <remarks>
            The last character index of the token.
            This method is optional; return -1 if not implemented.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.TokenSource">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            which created this token.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.InputStream">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            from which this token was derived.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.EmptySource">
            <summary>
            An empty
            <see cref="T:Antlr4.Runtime.Sharpen.Tuple`2"/>
            which is used as the default value of
            <see cref="F:Antlr4.Runtime.CommonToken.source"/>
            for tokens that do not have a source.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.type">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Type"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.line">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Line"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.charPositionInLine">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Column"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.channel">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Channel"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.source">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.CommonToken.TokenSource"/>
            and
            <see cref="P:Antlr4.Runtime.CommonToken.InputStream"/>
            .
            <p>
            These properties share a field to reduce the memory footprint of
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            . Tokens created by a
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            from
            the same source and input stream share a reference to the same
            <see cref="T:Antlr4.Runtime.Sharpen.Tuple`2"/>
            containing these values.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.text">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Text"/> property.
            </summary>
            <seealso cref="P:Antlr4.Runtime.CommonToken.Text"/>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.index">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.TokenIndex"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.start">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.StartIndex"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.stop">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.StopIndex"/> property.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.CommonToken.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            with the specified token type.
            </summary>
            <param name="type">The token type.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonToken.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            with the specified token type and
            text.
            </summary>
            <param name="type">The token type.</param>
            <param name="text">The text of the token.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonToken.#ctor(Antlr4.Runtime.IToken)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            as a copy of another
            <see cref="T:Antlr4.Runtime.IToken"/>
            .
            <p>
            If
            <code>oldToken</code>
            is also a
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            instance, the newly
            constructed token will share a reference to the
            <see cref="F:Antlr4.Runtime.CommonToken.text"/>
            field and
            the
            <see cref="T:Antlr4.Runtime.Sharpen.Tuple`2"/>
            stored in
            <see cref="F:Antlr4.Runtime.CommonToken.source"/>
            . Otherwise,
            <see cref="F:Antlr4.Runtime.CommonToken.text"/>
            will
            be assigned the result of calling
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            , and
            <see cref="F:Antlr4.Runtime.CommonToken.source"/>
            will be constructed from the result of
            <see cref="P:Antlr4.Runtime.IToken.TokenSource"/>
            and
            <see cref="P:Antlr4.Runtime.IToken.InputStream"/>
            .</p>
            </summary>
            <param name="oldToken">The token to copy.</param>
        </member>
        <member name="P:Antlr4.Runtime.CommonToken.Text">
            <summary>Explicitly set the text for this token.</summary>
            <remarks>
            Explicitly set the text for this token. If {code text} is not
            <code>null</code>
            , then
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            will return this value rather than
            extracting the text from the input.
            </remarks>
            <value>
            The explicit text of the token, or
            <code>null</code>
            if the text
            should be obtained from the input along with the start and stop indexes
            of the token.
            </value>
        </member>
        <member name="T:Antlr4.Runtime.CommonTokenFactory">
            <summary>
            This default implementation of
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            creates
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            objects.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.ITokenFactory">
            <summary>The default mechanism for creating tokens.</summary>
            <remarks>
            The default mechanism for creating tokens. It's used by default in Lexer and
            the error handling strategy (to create missing tokens).  Notifying the parser
            of a new factory means that it notifies it's token source and error strategy.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ITokenFactory.Create(Antlr4.Runtime.Sharpen.Tuple{Antlr4.Runtime.ITokenSource,Antlr4.Runtime.ICharStream},System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This is the method used to create tokens in the lexer and in the
            error handling strategy.
            </summary>
            <remarks>
            This is the method used to create tokens in the lexer and in the
            error handling strategy. If text!=null, than the start and stop positions
            are wiped to -1 in the text override is set in the CommonToken.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ITokenFactory.Create(System.Int32,System.String)">
            <summary>Generically useful</summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenFactory.Default">
            <summary>
            The default
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            instance.
            <p>
            This token factory does not explicitly copy token text when constructing
            tokens.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenFactory.copyText">
            <summary>
            Indicates whether
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            should be called after
            constructing tokens to explicitly set the text. This is useful for cases
            where the input stream might not be able to provide arbitrary substrings
            of text from the input after the lexer creates a token (e.g. the
            implementation of
            <see cref="M:Antlr4.Runtime.ICharStream.GetText(Antlr4.Runtime.Misc.Interval)"/>
            in
            <see cref="T:Antlr4.Runtime.UnbufferedCharStream"/>
            throws an
            <see cref="T:System.NotSupportedException"/>
            ). Explicitly setting the token text
            allows
            <see cref="P:Antlr4.Runtime.IToken.Text"/>
            to be called at any time regardless of the
            input stream implementation.
            <p>
            The default value is
            <code>false</code>
            to avoid the performance and memory
            overhead of copying text for every token unless explicitly requested.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenFactory.#ctor(System.Boolean)">
            <summary>
            Constructs a
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            with the specified value for
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.copyText"/>
            .
            <p>
            When
            <code>copyText</code>
            is
            <code>false</code>
            , the
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.Default"/>
            instance
            should be used instead of constructing a new instance.</p>
            </summary>
            <param name="copyText">
            The value for
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.copyText"/>
            .
            </param>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenFactory.#ctor">
            <summary>
            Constructs a
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            with
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.copyText"/>
            set to
            <code>false</code>
            .
            <p>
            The
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.Default"/>
            instance should be used instead of calling this
            directly.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.CommonTokenStream">
            <summary>
            This class extends
            <see cref="T:Antlr4.Runtime.BufferedTokenStream"/>
            with functionality to filter
            token streams to tokens on a particular channel (tokens where
            <see cref="P:Antlr4.Runtime.IToken.Channel"/>
            returns a particular value).
            <p>
            This token stream provides access to all tokens by index or when calling
            methods like
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.GetText"/>
            . The channel filtering is only used for code
            accessing tokens via the lookahead methods
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.La(System.Int32)"/>
            ,
            <see cref="M:Antlr4.Runtime.CommonTokenStream.Lt(System.Int32)"/>
            , and
            <see cref="M:Antlr4.Runtime.CommonTokenStream.Lb(System.Int32)"/>
            .</p>
            <p>
            By default, tokens are placed on the default channel
            (
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            ), but may be reassigned by using the
            <code>-&gt;channel(HIDDEN)</code>
            lexer command, or by using an embedded action to
            call
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            .
            </p>
            <p>
            Note: lexer rules which use the
            <code>-&gt;skip</code>
            lexer command or call
            <see cref="M:Antlr4.Runtime.Lexer.Skip"/>
            do not produce tokens at all, so input text matched by
            such a rule will not be available as part of the token stream, regardless of
            channel.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenStream.channel">
            <summary>Specifies the channel to use for filtering tokens.</summary>
            <remarks>
            Specifies the channel to use for filtering tokens.
            <p>
            The default value is
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            , which matches the
            default channel assigned to tokens created by the lexer.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenStream.#ctor(Antlr4.Runtime.ITokenSource)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            using the specified token
            source and the default token channel (
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            ).
            </summary>
            <param name="tokenSource">The token source.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenStream.#ctor(Antlr4.Runtime.ITokenSource,System.Int32)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            using the specified token
            source and filtering tokens to the specified channel. Only tokens whose
            <see cref="P:Antlr4.Runtime.IToken.Channel"/>
            matches
            <code>channel</code>
            or have the
            <see cref="P:Antlr4.Runtime.IToken.Type"/>
            equal to
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            will be returned by the
            token stream lookahead methods.
            </summary>
            <param name="tokenSource">The token source.</param>
            <param name="channel">The channel to use for filtering tokens.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenStream.GetNumberOfOnChannelTokens">
            <summary>Count EOF just once.</summary>
            <remarks>Count EOF just once.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.ConsoleErrorListener`1">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.ConsoleErrorListener`1.Instance">
            <summary>
            Provides a default instance of
            <see cref="T:Antlr4.Runtime.ConsoleErrorListener`1"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ConsoleErrorListener`1.SyntaxError(Antlr4.Runtime.IRecognizer,`0,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc/>
            <p>
            This implementation prints messages to
            <see cref="P:System.Console.Error"/>
            containing the
            values of
            <code>line</code>
            ,
            <code>charPositionInLine</code>
            , and
            <code>msg</code>
            using
            the following format.</p>
            <pre>
            line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>
            </pre>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Dependents">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.AbstractEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.IEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.ArrayEdgeMap`1">
            <author>sam</author>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.states">
            <summary>A set of all DFA states.</summary>
            <remarks>
            A set of all DFA states. Use
            <see cref="T:System.Collections.Generic.IDictionary`2"/>
            so we can get old state back
            (
            <see cref="T:System.Collections.Generic.HashSet`1"/>
            only allows you to see if it's there).
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.atnStartState">
            <summary>From which ATN state did we create this DFA?</summary>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.precedenceDfa">
            <summary>
            <code>true</code>
            if this DFA is for a precedence decision; otherwise,
            <code>false</code>
            . This is the backing field for <see cref="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa"/>.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFA.GetPrecedenceStartState(System.Int32,System.Boolean)">
            <summary>Get the start state for a specific precedence value.</summary>
            <remarks>Get the start state for a specific precedence value.</remarks>
            <param name="precedence">The current precedence.</param>
            <returns>
            The start state corresponding to the specified precedence, or
            <code>null</code>
            if no start state exists for the specified precedence.
            </returns>
            <exception cref="T:System.InvalidOperationException">if this is not a precedence DFA.</exception>
            <seealso cref="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa"/>
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFA.SetPrecedenceStartState(System.Int32,System.Boolean,Antlr4.Runtime.Dfa.DFAState)">
            <summary>Set the start state for a specific precedence value.</summary>
            <remarks>Set the start state for a specific precedence value.</remarks>
            <param name="precedence">The current precedence.</param>
            <param name="startState">
            The start state corresponding to the specified
            precedence.
            </param>
            <exception cref="T:System.InvalidOperationException">if this is not a precedence DFA.</exception>
            <seealso cref="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa"/>
        </member>
        <member name="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa">
            <summary>Gets whether this DFA is a precedence DFA.</summary>
            <remarks>
            Gets whether this DFA is a precedence DFA. Precedence DFAs use a special
            start state
            <see cref="F:Antlr4.Runtime.Dfa.DFA.s0"/>
            which is not stored in
            <see cref="F:Antlr4.Runtime.Dfa.DFA.states"/>
            . The
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.edges"/>
            array for this start state contains outgoing edges
            supplying individual start states corresponding to specific precedence
            values.
            </remarks>
            <returns>
            
            <code>true</code>
            if this is a precedence DFA; otherwise,
            <code>false</code>
            .
            </returns>
            <seealso cref="P:Antlr4.Runtime.Parser.Precedence"/>
            <summary>Sets whether this is a precedence DFA.</summary>
            <remarks>
            Sets whether this is a precedence DFA. If the specified value differs
            from the current DFA configuration, the following actions are taken;
            otherwise no changes are made to the current DFA.
            <ul>
            <li>The
            <see cref="F:Antlr4.Runtime.Dfa.DFA.states"/>
            map is cleared</li>
            <li>If
            <code>precedenceDfa</code>
            is
            <code>false</code>
            , the initial state
            <see cref="F:Antlr4.Runtime.Dfa.DFA.s0"/>
            is set to
            <code>null</code>
            ; otherwise, it is initialized to a new
            <see cref="T:Antlr4.Runtime.Dfa.DFAState"/>
            with an empty outgoing
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.edges"/>
            array to
            store the start states for individual precedence values.</li>
            <li>The
            <see cref="F:Antlr4.Runtime.Dfa.DFA.precedenceDfa"/>
            field is updated</li>
            </ul>
            </remarks>
            <value>
            
            <code>true</code>
            if this is a precedence DFA; otherwise,
            <code>false</code>
            </value>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.DFASerializer">
            <summary>A DFA walker that knows how to dump them to serialized strings.</summary>
            <remarks>A DFA walker that knows how to dump them to serialized strings.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.DFAState">
            <summary>A DFA state represents a set of possible ATN configurations.</summary>
            <remarks>
            A DFA state represents a set of possible ATN configurations.
            As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
            to keep track of all possible states the ATN can be in after
            reading each input symbol.  That is to say, after reading
            input a1a2..an, the DFA is in a state that represents the
            subset T of the states of the ATN that are reachable from the
            ATN's start state along some path labeled a1a2..an."
            In conventional NFA&#x2192;DFA conversion, therefore, the subset T
            would be a bitset representing the set of states the
            ATN could be in.  We need to track the alt predicted by each
            state as well, however.  More importantly, we need to maintain
            a stack of states, tracking the closure operations as they
            jump from rule to rule, emulating rule invocations (method calls).
            I have to add a stack to simulate the proper lookahead sequences for
            the underlying LL grammar from which the ATN was derived.
            <p>I use a set of ATNConfig objects not simple states.  An ATNConfig
            is both a state (ala normal conversion) and a RuleContext describing
            the chain of rules (if any) followed to arrive at that state.</p>
            <p>A DFA state may have multiple references to a particular state,
            but with different ATN contexts (with same or different alts)
            meaning that state was reached via a different set of rule invocations.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.edges">
            <summary>
            <code>edges.get(symbol)</code>
            points to target of symbol.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.prediction">
            <summary>
            if accept state, what ttype do we match or alt do we predict?
            This is set to
            <see cref="F:Antlr4.Runtime.Atn.ATN.InvalidAltNumber"/>
            when
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.predicates"/>
            <code>!=null</code>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.contextEdges">
            <summary>These keys for these edges are the top level element of the global context.</summary>
            <remarks>These keys for these edges are the top level element of the global context.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.contextSymbols">
            <summary>Symbols in this set require a global context transition before matching an input symbol.</summary>
            <remarks>Symbols in this set require a global context transition before matching an input symbol.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.predicates">
            <summary>
            This list is computed by
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.PredicateDFAState(Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFAState.Equals(System.Object)">
            <summary>
            Two
            <see cref="T:Antlr4.Runtime.Dfa.DFAState"/>
            instances are equal if their ATN configuration sets
            are the same. This method is used to see if a state already exists.
            <p>Because the number of alternatives and number of ATN configurations are
            finite, there is a finite number of DFA states that can be processed.
            This is necessary to show that the algorithm terminates.</p>
            <p>Cannot test the DFA state numbers here because in
            <see cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.PredictionContextCache)"/>
            we need to know if any other state
            exists that has this exact set of ATN configurations. The
            <see cref="F:Antlr4.Runtime.Dfa.DFAState.stateNumber"/>
            is irrelevant.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.DFAState.PredPrediction">
            <summary>Map a predicate to a predicted alternative.</summary>
            <remarks>Map a predicate to a predicted alternative.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.SingletonEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.SparseEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.DiagnosticErrorListener">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            can be used to identify
            certain potential correctness and performance problems in grammars. "Reports"
            are made by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            with the appropriate
            message.
            <ul>
            <li><b>Ambiguities</b>: These are cases where more than one path through the
            grammar can match the input.</li>
            <li><b>Weak context sensitivity</b>: These are cases where full-context
            prediction resolved an SLL conflict to a unique alternative which equaled the
            minimum alternative of the SLL conflict.</li>
            <li><b>Strong (forced) context sensitivity</b>: These are cases where the
            full-context prediction resolved an SLL conflict to a unique alternative,
            <em>and</em> the minimum alternative of the SLL conflict was found to not be
            a truly viable alternative. Two-stage parsing cannot be used for inputs where
            this situation occurs.</li>
            </ul>
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.DiagnosticErrorListener.exactOnly">
            <summary>
            When
            <code>true</code>
            , only exactly known ambiguities are reported.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.#ctor">
            <summary>
            Initializes a new instance of
            <see cref="T:Antlr4.Runtime.DiagnosticErrorListener"/>
            which only
            reports exact ambiguities.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of
            <see cref="T:Antlr4.Runtime.DiagnosticErrorListener"/>
            , specifying
            whether all ambiguities or only exact ambiguities are reported.
            </summary>
            <param name="exactOnly">
            
            <code>true</code>
            to report only exact ambiguities, otherwise
            <code>false</code>
            to report all ambiguities.
            </param>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.GetConflictingAlts(Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>
            Computes the set of conflicting or ambiguous alternatives from a
            configuration set, if that information was not already provided by the
            parser.
            </summary>
            <remarks>
            Computes the set of conflicting or ambiguous alternatives from a
            configuration set, if that information was not already provided by the
            parser.
            </remarks>
            <param name="reportedAlts">
            The set of conflicting or ambiguous alternatives, as
            reported by the parser.
            </param>
            <param name="configs">The conflicting or ambiguous configuration set.</param>
            <returns>
            Returns
            <code>reportedAlts</code>
            if it is not
            <code>null</code>
            , otherwise
            returns the set of alternatives represented in
            <code>configs</code>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.FailedPredicateException">
            <summary>A semantic predicate failed during validation.</summary>
            <remarks>
            A semantic predicate failed during validation.  Validation of predicates
            occurs when normally parsing the alternative just like matching a token.
            Disambiguating predicate evaluation occurs when we test a predicate during
            prediction.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.RecognitionException">
            <summary>The root of the ANTLR exception hierarchy.</summary>
            <remarks>
            The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
            3 kinds of errors: prediction errors, failed predicate errors, and
            mismatched input errors. In each case, the parser knows where it is
            in the input, where it is in the ATN, the rule invocation stack,
            and what kind of problem occurred.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.RecognitionException.recognizer">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.IRecognizer"/>
            where this exception originated.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.RecognitionException.offendingToken">
            <summary>
            The current
            <see cref="T:Antlr4.Runtime.IToken"/>
            when an error occurred. Since not all streams
            support accessing symbols by index, we have to track the
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance itself.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.RecognitionException.GetExpectedTokens">
            <summary>
            Gets the set of input symbols which could potentially follow the
            previously matched symbol at the time this exception was thrown.
            </summary>
            <remarks>
            Gets the set of input symbols which could potentially follow the
            previously matched symbol at the time this exception was thrown.
            <p>If the set of expected tokens is not known and could not be computed,
            this method returns
            <code>null</code>
            .</p>
            </remarks>
            <returns>
            The set of token types that could potentially follow the current
            state in the ATN, or
            <code>null</code>
            if the information is not available.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.OffendingState">
            <summary>
            Get the ATN state number the parser was in at the time the error
            occurred.
            </summary>
            <remarks>
            Get the ATN state number the parser was in at the time the error
            occurred. For
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            and
            <see cref="T:Antlr4.Runtime.LexerNoViableAltException"/>
            exceptions, this is the
            <see cref="T:Antlr4.Runtime.Atn.DecisionState"/>
            number. For others, it is the state whose outgoing
            edge we couldn't match.
            <p>If the state number is not known, this method returns -1.</p>
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.Context">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            at the time this exception was thrown.
            <p>If the context is not available, this method returns
            <code>null</code>
            .</p>
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            at the time this exception was thrown.
            If the context is not available, this method returns
            <code>null</code>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.InputStream">
            <summary>
            Gets the input stream which is the symbol source for the recognizer where
            this exception was thrown.
            </summary>
            <remarks>
            Gets the input stream which is the symbol source for the recognizer where
            this exception was thrown.
            <p>If the input stream is not available, this method returns
            <code>null</code>
            .</p>
            </remarks>
            <returns>
            The input stream which is the symbol source for the recognizer
            where this exception was thrown, or
            <code>null</code>
            if the stream is not
            available.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.Recognizer">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.IRecognizer"/>
            where this exception occurred.
            <p>If the recognizer is not available, this method returns
            <code>null</code>
            .</p>
            </summary>
            <returns>
            The recognizer where this exception occurred, or
            <code>null</code>
            if
            the recognizer is not available.
            </returns>
        </member>
        <member name="F:Antlr4.Runtime.IntStreamConstants.Eof">
            <summary>
            The value returned by
            <see cref="M:Antlr4.Runtime.IIntStream.La(System.Int32)">LA()</see>
            when the end of the stream is
            reached.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName">
            <summary>
            The value returned by
            <see cref="P:Antlr4.Runtime.IIntStream.SourceName"/>
            when the actual name of the
            underlying source is not known.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.InputMismatchException">
            <summary>
            This signifies any kind of mismatched input exceptions such as
            when the current input does not match the expected token.
            </summary>
            <remarks>
            This signifies any kind of mismatched input exceptions such as
            when the current input does not match the expected token.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.InterpreterRuleContext">
            <summary>
            This class extends
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            by allowing the value of
            <see cref="P:Antlr4.Runtime.InterpreterRuleContext.RuleIndex"/>
            to be explicitly set for the context.
            <p>
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            does not include field storage for the rule index
            since the context classes created by the code generator override the
            <see cref="P:Antlr4.Runtime.InterpreterRuleContext.RuleIndex"/>
            method to return the correct value for that context.
            Since the parser interpreter does not use the context classes generated for a
            parser, this class (with slightly more memory overhead per node) is used to
            provide equivalent functionality.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.ParserRuleContext">
            <summary>A rule invocation record for parsing.</summary>
            <remarks>
            A rule invocation record for parsing.
            Contains all of the information about the current rule not stored in the
            RuleContext. It handles parse tree children list, Any ATN state
            tracing, and the default values available for rule indications:
            start, stop, rule index, current alt number, current
            ATN state.
            Subclasses made for each rule and grammar track the parameters,
            return values, locals, and labels specific to that rule. These
            are the objects that are returned from rules.
            Note text is not an actual field of a rule return value; it is computed
            from start and stop using the input stream's toString() method.  I
            could add a ctor to this so that we can pass in and store the input
            stream, but I'm not sure we want to do that.  It would seem to be undefined
            to get the .text property anyway if the rule matches tokens from multiple
            input streams.
            I do not use getters for fields of objects that are used simply to
            group values such as this aggregate.  The getters/setters are there to
            satisfy the superclass interface.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.RuleContext">
            <summary>A rule context is a record of a single rule invocation.</summary>
            <remarks>
            A rule context is a record of a single rule invocation. It knows
            which context invoked it, if any. If there is no parent context, then
            naturally the invoking state is not valid.  The parent link
            provides a chain upwards from the current rule invocation to the root
            of the invocation tree, forming a stack. We actually carry no
            information about the rule associated with this context (except
            when parsing). We keep only the state number of the invoking state from
            the ATN submachine that invoked this. Contrast this with the s
            pointer inside ParserRuleContext that tracks the current state
            being "executed" for the current rule.
            The parent contexts are useful for computing lookahead sets and
            getting error information.
            These objects are used during parsing and prediction.
            For the special case of parsers, we use the subclass
            ParserRuleContext.
            </remarks>
            <seealso cref="T:Antlr4.Runtime.ParserRuleContext"/>
        </member>
        <member name="T:Antlr4.Runtime.Tree.IParseTree">
            <summary>
            An interface to access the tree of
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            objects created
            during a parse that makes the data structure look like a simple parse tree.
            This node represents both internal nodes, rule invocations,
            and leaf nodes, token matches.
            <p>The payload is either a
            <see cref="T:Antlr4.Runtime.IToken"/>
            or a
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            object.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ISyntaxTree">
            <summary>
            A tree that knows about an interval in a token stream
            is some kind of syntax tree.
            </summary>
            <remarks>
            A tree that knows about an interval in a token stream
            is some kind of syntax tree. Subinterfaces distinguish
            between parse trees and other kinds of syntax trees we might want to create.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ITree">
            <summary>The basic notion of a tree has a parent, a payload, and a list of children.</summary>
            <remarks>
            The basic notion of a tree has a parent, a payload, and a list of children.
            It is the most abstract interface for all the trees used by ANTLR.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ITree.GetChild(System.Int32)">
            <summary>
            If there are children, get the
            <code>i</code>
            th value indexed from 0.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ITree.ToStringTree">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            <code>(root child1 .. childN)</code>
            . Print just a node if this is a leaf.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.Parent">
            <summary>The parent of this node.</summary>
            <remarks>
            The parent of this node. If the return value is null, then this
            node is the root of the tree.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.Payload">
            <summary>This method returns whatever object represents the data at this note.</summary>
            <remarks>
            This method returns whatever object represents the data at this note. For
            example, for parse trees, the payload can be a
            <see cref="T:Antlr4.Runtime.IToken"/>
            representing
            a leaf node or a
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            object representing a rule
            invocation. For abstract syntax trees (ASTs), this is a
            <see cref="T:Antlr4.Runtime.IToken"/>
            object.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.ChildCount">
            <summary>
            How many children are there? If there is none, then this
            node represents a leaf node.
            </summary>
            <remarks>
            How many children are there? If there is none, then this
            node represents a leaf node.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ISyntaxTree.SourceInterval">
            <summary>
            Return an
            <see cref="T:Antlr4.Runtime.Misc.Interval"/>
            indicating the index in the
            <see cref="T:Antlr4.Runtime.ITokenStream"/>
            of the first and last token associated with this
            subtree. If this node is a leaf, then the interval represents a single
            token.
            <p>If source interval is unknown, this returns
            <see cref="F:Antlr4.Runtime.Misc.Interval.Invalid"/>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.Accept``1(Antlr4.Runtime.Tree.IParseTreeVisitor{``0})">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTreeVisitor`1"/>
            needs a double dispatch method.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.GetText">
            <summary>Return the combined text of all leaf nodes.</summary>
            <remarks>
            Return the combined text of all leaf nodes. Does not get any
            off-channel tokens (if any) so won't return whitespace and
            comments if they are sent to parser on hidden channel.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.ToStringTree(Antlr4.Runtime.Parser)">
            <summary>
            Specialize toStringTree so that it can print out more information
            based upon the parser.
            </summary>
            <remarks>
            Specialize toStringTree so that it can print out more information
            based upon the parser.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.RuleContext.parent">
            <summary>What context invoked this rule?</summary>
        </member>
        <member name="F:Antlr4.Runtime.RuleContext.invokingState">
            <summary>
            What state invoked the rule associated with this context?
            The "return address" is the followState of invokingState
            If parent is null, this should be -1.
            </summary>
            <remarks>
            What state invoked the rule associated with this context?
            The "return address" is the followState of invokingState
            If parent is null, this should be -1.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.GetText">
            <summary>Return the combined text of all child nodes.</summary>
            <remarks>
            Return the combined text of all child nodes. This method only considers
            tokens which have been added to the parse tree.
            <p/>
            Since tokens on hidden channels (e.g. whitespace or comments) are not
            added to the parse trees, they will not appear in the output of this
            method.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.ToStringTree(Antlr4.Runtime.Parser)">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            (root child1 ..
            </summary>
            <remarks>
            Print out a whole tree, not just a node, in LISP format
            (root child1 .. childN). Print just a node if this is a leaf.
            We have to know the recognizer so we can get rule names.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.ToStringTree(System.Collections.Generic.IList{System.String})">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            (root child1 ..
            </summary>
            <remarks>
            Print out a whole tree, not just a node, in LISP format
            (root child1 .. childN). Print just a node if this is a leaf.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.RuleContext.IsEmpty">
            <summary>
            A context is empty if there is no invoking state; meaning nobody call
            current context.
            </summary>
            <remarks>
            A context is empty if there is no invoking state; meaning nobody call
            current context.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.children">
            <summary>
            If we are debugging or building a parse tree for a visitor,
            we need to track all of the tokens and rule invocations associated
            with this rule's context.
            </summary>
            <remarks>
            If we are debugging or building a parse tree for a visitor,
            we need to track all of the tokens and rule invocations associated
            with this rule's context. This is empty for parsing w/o tree constr.
            operation because we don't the need to track the details about
            how we parse this rule.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.start">
            <summary>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            </summary>
            <remarks>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            This list indicates the sequence of ATN nodes used to match
            the elements of the children list. This list does not include
            ATN nodes and other rules used to match rule invocations. It
            traces the rule invocation node itself but nothing inside that
            other rule's ATN submachine.
            There is NOT a one-to-one correspondence between the children and
            states list. There are typically many nodes in the ATN traversed
            for each element in the children list. For example, for a rule
            invocation there is the invoking state and the following state.
            The parser setState() method updates field s and adds it to this list
            if we are debugging/tracing.
            This does not trace states visited during prediction.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.stop">
            <summary>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            </summary>
            <remarks>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            This list indicates the sequence of ATN nodes used to match
            the elements of the children list. This list does not include
            ATN nodes and other rules used to match rule invocations. It
            traces the rule invocation node itself but nothing inside that
            other rule's ATN submachine.
            There is NOT a one-to-one correspondence between the children and
            states list. There are typically many nodes in the ATN traversed
            for each element in the children list. For example, for a rule
            invocation there is the invoking state and the following state.
            The parser setState() method updates field s and adds it to this list
            if we are debugging/tracing.
            This does not trace states visited during prediction.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.exception">
            <summary>The exception that forced this rule to return.</summary>
            <remarks>
            The exception that forced this rule to return. If the rule successfully
            completed, this is
            <code>null</code>
            .
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.CopyFrom(Antlr4.Runtime.ParserRuleContext)">
            <summary>COPY a ctx (I'm deliberately not using copy constructor)</summary>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>Does not set parent link; other add methods do that</summary>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.RemoveLastChild">
            <summary>
            Used by enterOuterAlt to toss out a RuleContext previously added as
            we entered a rule.
            </summary>
            <remarks>
            Used by enterOuterAlt to toss out a RuleContext previously added as
            we entered a rule. If we have # label, we will need to remove
            generic ruleContext object.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.ToInfoString(Antlr4.Runtime.Parser)">
            <summary>Used for rule context info debugging during parse-time, not so much for ATN debugging</summary>
        </member>
        <member name="F:Antlr4.Runtime.InterpreterRuleContext.ruleIndex">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.InterpreterRuleContext.RuleIndex"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.InterpreterRuleContext.#ctor(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.InterpreterRuleContext"/>
            with the specified
            parent, invoking state, and rule index.
            </summary>
            <param name="parent">The parent context.</param>
            <param name="invokingStateNumber">The invoking state number.</param>
            <param name="ruleIndex">The rule index for the current context.</param>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.Epsilon">
            <summary>
            During lookahead operations, this "token" signifies we hit rule end ATN state
            and did not follow it despite needing to.
            </summary>
            <remarks>
            During lookahead operations, this "token" signifies we hit rule end ATN state
            and did not follow it despite needing to.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.DefaultChannel">
            <summary>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".
            </summary>
            <remarks>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".  The parser tunes to a particular channel
            so that whitespace etc... can go to the parser on a "hidden" channel.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.HiddenChannel">
            <summary>
            Anything on different channel than DEFAULT_CHANNEL is not parsed
            by parser.
            </summary>
            <remarks>
            Anything on different channel than DEFAULT_CHANNEL is not parsed
            by parser.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.ITokenSource">
            <summary>
            A source of tokens must provide a sequence of tokens via
            <see cref="M:Antlr4.Runtime.ITokenSource.NextToken"/>
            and also must reveal it's source of characters;
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            's text is
            computed from a
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            ; it only store indices into the char
            stream.
            <p>Errors from the lexer are never passed to the parser. Either you want to keep
            going or you do not upon token recognition error. If you do not want to
            continue lexing then you do not want to continue parsing. Just throw an
            exception not under
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            and Java will naturally toss
            you all the way out of the recognizers. If you want to continue lexing then
            you should not throw an exception to the parser--it has already requested a
            token. Keep lexing until you get a valid one. Just report errors and keep
            going, looking for a valid token.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ITokenSource.NextToken">
            <summary>
            Return a
            <see cref="T:Antlr4.Runtime.IToken"/>
            object from your input stream (usually a
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            ). Do not fail/return upon lexing error; keep chewing
            on the characters until you get a good one; errors are not passed through
            to the parser.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.Line">
            <summary>Get the line number for the current position in the input stream.</summary>
            <remarks>
            Get the line number for the current position in the input stream. The
            first line in the input is line 1.
            </remarks>
            <returns>
            The line number for the current position in the input stream, or
            0 if the current token source does not track line numbers.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.Column">
            <summary>
            Get the index into the current line for the current position in the input
            stream.
            </summary>
            <remarks>
            Get the index into the current line for the current position in the input
            stream. The first character on a line has position 0.
            </remarks>
            <returns>
            The line number for the current position in the input stream, or
            -1 if the current token source does not track character positions.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.InputStream">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            from which this token source is currently
            providing tokens.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            associated with the current position in
            the input, or
            <code>null</code>
            if no input stream is available for the token
            source.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.SourceName">
            <summary>Gets the name of the underlying input source.</summary>
            <remarks>
            Gets the name of the underlying input source. This method returns a
            non-null, non-empty string. If such a name is not known, this method
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName"/>
            .
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.TokenFactory">
            <summary>
            Set the
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            this token source should use for creating
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects from the input.
            </summary>
            <value>
            The
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            to use for creating tokens.
            </value>
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            this token source is currently using for
            creating
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects from the input.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            currently used by this token source.
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Lexer">
            <summary>A lexer is recognizer that draws input symbols from a character stream.</summary>
            <remarks>
            A lexer is recognizer that draws input symbols from a character stream.
            lexer grammars result in a subclass of this object. A Lexer object
            uses simplified match() and error recovery mechanisms in the interest
            of speed.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.GetErrorHeader(Antlr4.Runtime.RecognitionException)">
            <summary>What is the error header, normally line/character position information?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.GetTokenErrorDisplay(Antlr4.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.
            </summary>
            <remarks>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.toString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new Java type.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.AddErrorListener(Antlr4.Runtime.IAntlrErrorListener{`0})">
            <exception>
            NullPointerException
            if
            <code>listener</code>
            is
            <code>null</code>
            .
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.TokenNames">
            <summary>
            Used to print out token names like ID during debugging and
            error reporting.
            </summary>
            <remarks>
            Used to print out token names like ID during debugging and
            error reporting.  The generated parsers implement a method
            that overrides this to point to their String[] tokenNames.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.TokenTypeMap">
            <summary>Get a map from token names to token types.</summary>
            <remarks>
            Get a map from token names to token types.
            <p>Used for XPath and tree pattern compilation.</p>
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.RuleIndexMap">
            <summary>Get a map from rule names to rule indexes.</summary>
            <remarks>
            Get a map from rule names to rule indexes.
            <p>Used for XPath and tree pattern compilation.</p>
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.SerializedAtn">
            <summary>
            If this recognizer was generated, it will have a serialized ATN
            representation of the grammar.
            </summary>
            <remarks>
            If this recognizer was generated, it will have a serialized ATN
            representation of the grammar.
            <p>For interpreters, we don't know their serialized ATN despite having
            created the interpreter from it.</p>
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.GrammarFileName">
            <summary>For debugging and other purposes, might want the grammar name.</summary>
            <remarks>
            For debugging and other purposes, might want the grammar name.
            Have ANTLR generate an implementation for this method.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.Atn">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            used by the recognizer for prediction.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            used by the recognizer for prediction.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.Interpreter">
            <summary>Get the ATN interpreter used by the recognizer for prediction.</summary>
            <remarks>Get the ATN interpreter used by the recognizer for prediction.</remarks>
            <returns>The ATN interpreter used by the recognizer for prediction.</returns>
            <summary>Set the ATN interpreter used by the recognizer for prediction.</summary>
            <remarks>Set the ATN interpreter used by the recognizer for prediction.</remarks>
            <value>
            The ATN interpreter used by the recognizer for
            prediction.
            </value>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.ParseInfo">
            <summary>
            If profiling during the parse/lex, this will return DecisionInfo records
            for each decision in recognizer in a ParseInfo object.
            </summary>
            <remarks>
            If profiling during the parse/lex, this will return DecisionInfo records
            for each decision in recognizer in a ParseInfo object.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.State">
            <summary>
            Indicate that the recognizer has changed internal state that is
            consistent with the ATN state passed in.
            </summary>
            <remarks>
            Indicate that the recognizer has changed internal state that is
            consistent with the ATN state passed in.  This way we always know
            where we are in the ATN as the parser goes along. The rule
            context objects form a stack that lets us see the stack of
            invoking rules. Combine this and we have complete ATN
            configuration information.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._factory">
            <summary>How to create token objects</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._token">
            <summary>The goal of all lexer rules/methods is to create a token object.</summary>
            <remarks>
            The goal of all lexer rules/methods is to create a token object.
            This is an instance variable as multiple rules may collaborate to
            create a single token.  nextToken will return this object after
            matching lexer rule(s).  If you subclass to allow multiple token
            emissions, then set this to the last token to be matched or
            something nonnull so that the auto token emit mechanism will not
            emit another token.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartCharIndex">
            <summary>
            What character index in the stream did the current token start at?
            Needed, for example, to get the text for current token.
            </summary>
            <remarks>
            What character index in the stream did the current token start at?
            Needed, for example, to get the text for current token.  Set at
            the start of nextToken.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartLine">
            <summary>The line on which the first character of the token resides</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartCharPositionInLine">
            <summary>The character position of first character within the line</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._hitEOF">
            <summary>Once we see EOF on char stream, next token will be EOF.</summary>
            <remarks>
            Once we see EOF on char stream, next token will be EOF.
            If you have DONE : EOF ; then you see DONE EOF.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._channel">
            <summary>The channel number for the current token</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._type">
            <summary>The token type for the current token</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._text">
            <summary>
            You can set the text for the current token to override what is in
            the input char buffer.
            </summary>
            <remarks>
            You can set the text for the current token to override what is in
            the input char buffer.  Use setText() or can set this instance var.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.NextToken">
            <summary>
            Return a token from this source; i.e., match a token on the char
            stream.
            </summary>
            <remarks>
            Return a token from this source; i.e., match a token on the char
            stream.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Skip">
            <summary>
            Instruct the lexer to skip creating a token for current lexer rule
            and look for another token.
            </summary>
            <remarks>
            Instruct the lexer to skip creating a token for current lexer rule
            and look for another token.  nextToken() knows to keep looking when
            a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
            if token==null at end of any token rule, it creates one for you
            and emits it.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.SetInputStream(Antlr4.Runtime.ICharStream)">
            <summary>Set the char stream and reset the lexer</summary>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Emit(Antlr4.Runtime.IToken)">
            <summary>
            By default does not support multiple emits per nextToken invocation
            for efficiency reasons.
            </summary>
            <remarks>
            By default does not support multiple emits per nextToken invocation
            for efficiency reasons.  Subclass and override this method, nextToken,
            and getToken (to push tokens into a list and pull from that list
            rather than a single variable as this implementation does).
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Emit">
            <summary>
            The standard method called to automatically emit a token at the
            outermost lexical rule.
            </summary>
            <remarks>
            The standard method called to automatically emit a token at the
            outermost lexical rule.  The token object should point into the
            char buffer start..stop.  If there is a text override in 'text',
            use that to set the token's text.  Override this method to emit
            custom Token objects or provide a new factory.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.GetAllTokens">
            <summary>Return a list of all Token objects in input char stream.</summary>
            <remarks>
            Return a list of all Token objects in input char stream.
            Forces load of all tokens. Does not include EOF token.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Recover(Antlr4.Runtime.RecognitionException)">
            <summary>
            Lexers can normally match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.
            </summary>
            <remarks>
            Lexers can normally match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.  You can instead use the rule invocation stack
            to do sophisticated error recovery if you are in a fragment rule.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.CharIndex">
            <summary>What is the index of the current character of lookahead?</summary>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.Text">
            <summary>
            Return the text matched so far for the current token or any text
            override.
            </summary>
            <remarks>
            Return the text matched so far for the current token or any text
            override.
            </remarks>
            <summary>
            Set the complete text of this token; it wipes any previous changes to the
            text.
            </summary>
            <remarks>
            Set the complete text of this token; it wipes any previous changes to the
            text.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.Token">
            <summary>Override if emitting multiple tokens.</summary>
            <remarks>Override if emitting multiple tokens.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.TokenNames">
            <summary>
            Used to print out token names like ID during debugging and
            error reporting.
            </summary>
            <remarks>
            Used to print out token names like ID during debugging and
            error reporting.  The generated parsers implement a method
            that overrides this to point to their String[] tokenNames.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.LexerNoViableAltException.startIndex">
            <summary>Matching attempted at what input index?</summary>
        </member>
        <member name="F:Antlr4.Runtime.LexerNoViableAltException.deadEndConfigs">
            <summary>Which configurations did we try at input.index() that couldn't match input.LA(1)?</summary>
        </member>
        <member name="T:Antlr4.Runtime.ListTokenSource">
            <summary>
            Provides an implementation of
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            as a wrapper around a list
            of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects.
            <p>If the final token in the list is an
            <see cref="F:Antlr4.Runtime.TokenConstants.Eof"/>
            token, it will be used
            as the EOF token for every call to
            <see cref="M:Antlr4.Runtime.ListTokenSource.NextToken"/>
            after the end of the
            list is reached. Otherwise, an EOF token will be created.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.tokens">
            <summary>
            The wrapped collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects to return.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.sourceName">
            <summary>The name of the input source.</summary>
            <remarks>
            The name of the input source. If this value is
            <code>null</code>
            , a call to
            <see cref="P:Antlr4.Runtime.ListTokenSource.SourceName"/>
            should return the source name used to create the
            the next token in
            <see cref="F:Antlr4.Runtime.ListTokenSource.tokens"/>
            (or the previous token if the end of
            the input has been reached).
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.i">
            <summary>
            The index into
            <see cref="F:Antlr4.Runtime.ListTokenSource.tokens"/>
            of token to return by the next call to
            <see cref="M:Antlr4.Runtime.ListTokenSource.NextToken"/>
            . The end of the input is indicated by this value
            being greater than or equal to the number of items in
            <see cref="F:Antlr4.Runtime.ListTokenSource.tokens"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.eofToken">
            <summary>This field caches the EOF token for the token source.</summary>
            <remarks>This field caches the EOF token for the token source.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource._factory">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.ListTokenSource.TokenFactory"/> property.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ListTokenSource.#ctor(System.Collections.Generic.IList{Antlr4.Runtime.IToken})">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.ListTokenSource"/>
            instance from the specified
            collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects.
            </summary>
            <param name="tokens">
            The collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects to provide as a
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            .
            </param>
            <exception>
            NullPointerException
            if
            <code>tokens</code>
            is
            <code>null</code>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.ListTokenSource.#ctor(System.Collections.Generic.IList{Antlr4.Runtime.IToken},System.String)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.ListTokenSource"/>
            instance from the specified
            collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects and source name.
            </summary>
            <param name="tokens">
            The collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects to provide as a
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            .
            </param>
            <param name="sourceName">
            The name of the
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            . If this value is
            <code>null</code>
            ,
            <see cref="P:Antlr4.Runtime.ListTokenSource.SourceName"/>
            will attempt to infer the name from
            the next
            <see cref="T:Antlr4.Runtime.IToken"/>
            (or the previous token if the end of the input has
            been reached).
            </param>
            <exception>
            NullPointerException
            if
            <code>tokens</code>
            is
            <code>null</code>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.ListTokenSource.NextToken">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.Column">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.Line">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.InputStream">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.SourceName">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.TokenFactory">
            <summary><inheritDoc/></summary>
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:Antlr4.Runtime.Misc.Args">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Args.NotNull(System.String,System.Object)">
            <exception cref="T:System.ArgumentNullException">
            if
            <code>value</code>
            is
            <code>null</code>
            .
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.Misc.MurmurHash">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Initialize">
            <summary>Initialize the hash using the default seed value.</summary>
            <remarks>Initialize the hash using the default seed value.</remarks>
            <returns>the intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Initialize(System.Int32)">
            <summary>
            Initialize the hash using the specified
            <code>seed</code>
            .
            </summary>
            <param name="seed">the seed</param>
            <returns>the intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Int32)">
            <summary>
            Update the intermediate hash value for the next input
            <code>value</code>
            .
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="value">the value to add to the current hash</param>
            <returns>the updated intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Object)">
            <summary>
            Update the intermediate hash value for the next input
            <code>value</code>
            .
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="value">the value to add to the current hash</param>
            <returns>the updated intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Finish(System.Int32,System.Int32)">
            <summary>
            Apply the final computation steps to the intermediate value
            <code>hash</code>
            to form the final result of the MurmurHash 3 hash function.
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="numberOfWords">the number of integer values added to the hash</param>
            <returns>the final hash result</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.HashCode``1(``0[],System.Int32)">
            <summary>
            Utility function to compute the hash code of an array using the
            MurmurHash algorithm.
            </summary>
            <remarks>
            Utility function to compute the hash code of an array using the
            MurmurHash algorithm.
            </remarks>
            <param name="data">the array data</param>
            <param name="seed">the seed for the MurmurHash algorithm</param>
            <returns>the hash code of the data</returns>
        </member>
        <member name="T:Antlr4.Runtime.Misc.IIntSet">
            <summary>A generic set of integers.</summary>
            <remarks>A generic set of integers.</remarks>
            <seealso cref="T:Antlr4.Runtime.Misc.IntervalSet"/>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Add(System.Int32)">
            <summary>Adds the specified value to the current set.</summary>
            <remarks>Adds the specified value to the current set.</remarks>
            <param name="el">the value to add</param>
            <exception>
            IllegalStateException
            if the current set is read-only
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.AddAll(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Modify the current
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object to contain all elements that are
            present in itself, the specified
            <code>set</code>
            , or both.
            </summary>
            <param name="set">
            The set to add to the current set. A
            <code>null</code>
            argument is
            treated as though it were an empty set.
            </param>
            <returns>
            
            <code>this</code>
            (to support chained calls)
            </returns>
            <exception>
            IllegalStateException
            if the current set is read-only
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.And(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in both the current set and the specified set
            <code>a</code>
            .
            </summary>
            <param name="a">
            The set to intersect with the current set. A
            <code>null</code>
            argument is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the intersection of the
            current set and
            <code>a</code>
            . The value
            <code>null</code>
            may be returned in
            place of an empty result set.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Complement(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in
            <code>elements</code>
            but not present in the current set. The
            following expressions are equivalent for input non-null
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instances
            <code>x</code>
            and
            <code>y</code>
            .
            <ul>
            <li>
            <code>x.complement(y)</code>
            </li>
            <li>
            <code>y.subtract(x)</code>
            </li>
            </ul>
            </summary>
            <param name="elements">
            The set to compare with the current set. A
            <code>null</code>
            argument is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the elements present in
            <code>elements</code>
            but not present in the current set. The value
            <code>null</code>
            may be returned in place of an empty result set.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Or(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in the current set, the specified set
            <code>a</code>
            , or both.
            <p>
            This method is similar to
            <see cref="M:Antlr4.Runtime.Misc.IIntSet.AddAll(Antlr4.Runtime.Misc.IIntSet)"/>
            , but returns a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance instead of modifying the current set.</p>
            </summary>
            <param name="a">
            The set to union with the current set. A
            <code>null</code>
            argument
            is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the union of the current
            set and
            <code>a</code>
            . The value
            <code>null</code>
            may be returned in place of an
            empty result set.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Subtract(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in the current set but not present in the input set
            <code>a</code>
            .
            The following expressions are equivalent for input non-null
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instances
            <code>x</code>
            and
            <code>y</code>
            .
            <ul>
            <li>
            <code>y.subtract(x)</code>
            </li>
            <li>
            <code>x.complement(y)</code>
            </li>
            </ul>
            </summary>
            <param name="a">
            The set to compare with the current set. A
            <code>null</code>
            argument is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the elements present in
            <code>elements</code>
            but not present in the current set. The value
            <code>null</code>
            may be returned in place of an empty result set.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Equals(System.Object)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Contains(System.Int32)">
            <summary>
            Returns
            <code>true</code>
            if the set contains the specified element.
            </summary>
            <param name="el">The element to check for.</param>
            <returns>
            
            <code>true</code>
            if the set contains
            <code>el</code>
            ; otherwise
            <code>false</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Remove(System.Int32)">
            <summary>Removes the specified value from the current set.</summary>
            <remarks>
            Removes the specified value from the current set. If the current set does
            not contain the element, no changes are made.
            </remarks>
            <param name="el">the value to remove</param>
            <exception>
            IllegalStateException
            if the current set is read-only
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.ToList">
            <summary>Return a list containing the elements represented by the current set.</summary>
            <remarks>
            Return a list containing the elements represented by the current set. The
            list is returned in ascending numerical order.
            </remarks>
            <returns>
            A list containing all element present in the current set, sorted
            in ascending numerical order.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.ToString">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IIntSet.Count">
            <summary>Return the total number of elements represented by the current set.</summary>
            <remarks>Return the total number of elements represented by the current set.</remarks>
            <returns>
            the total number of elements represented by the current set,
            regardless of the manner in which the elements are stored.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IIntSet.IsNil">
            <summary>
            Returns
            <code>true</code>
            if this set contains no elements.
            </summary>
            <returns>
            
            <code>true</code>
            if the current set contains no elements; otherwise,
            <code>false</code>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IIntSet.SingleElement">
            <summary>
            Returns the single value contained in the set, if
            <see cref="P:Antlr4.Runtime.Misc.IIntSet.Count"/>
            is 1;
            otherwise, returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </summary>
            <returns>
            the single value contained in the set, if
            <see cref="P:Antlr4.Runtime.Misc.IIntSet.Count"/>
            is 1;
            otherwise, returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Misc.Interval">
            <summary>An immutable inclusive interval a..b.</summary>
            <remarks>An immutable inclusive interval a..b.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Misc.Interval.a">
            <summary>The start of the interval.</summary>
            <remarks>The start of the interval.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Misc.Interval.b">
            <summary>The end of the interval (inclusive).</summary>
            <remarks>The end of the interval (inclusive).</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Of(System.Int32,System.Int32)">
            <summary>
            Interval objects are used readonly so share all with the
            same single value a==b up to some max size.
            </summary>
            <remarks>
            Interval objects are used readonly so share all with the
            same single value a==b up to some max size.  Use an array as a perfect hash.
            Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
            Interval object with a..a in it.  On Java.g4, 218623 IntervalSets
            have a..a (set with 1 element).
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsBeforeDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start completely before other? Disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsBeforeNonDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start at or before other? Nondisjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfter(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this.a start after other.b? May or may not be disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfterDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start completely after other? Disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfterNonDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start after other? NonDisjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Disjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Are both ranges disjoint? I.e., no overlap?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Adjacent(Antlr4.Runtime.Misc.Interval)">
            <summary>Are two intervals adjacent such as 0..41 and 42..42?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Union(Antlr4.Runtime.Misc.Interval)">
            <summary>Return the interval computed from combining this and other</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Intersection(Antlr4.Runtime.Misc.Interval)">
            <summary>Return the interval in common between this and o</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.DifferenceNotProperlyContained(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the interval with elements from
            <code>this</code>
            not in
            <code>other</code>
            ;
            <code>other</code>
            must not be totally enclosed (properly contained)
            within
            <code>this</code>
            , which would result in two disjoint intervals
            instead of the single one returned by this method.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.Interval.Length">
            <summary>return number of elements between a and b inclusively.</summary>
            <remarks>
            return number of elements between a and b inclusively. x..x is length 1.
            if b &lt; a, then length is 0. 9..10 has length 2.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Misc.IntervalSet">
            <summary>
            This class implements the
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            backed by a sorted array of
            non-overlapping intervals. It is particularly efficient for representing
            large collections of numbers, where the majority of elements appear as part
            of a sequential range of numbers that are all part of the set. For example,
            the set { 1, 2, 3, 4, 7, 8 } may be represented as { [1, 4], [7, 8] }.
            <p>
            This class is able to represent sets containing any combination of values in
            the range
            <see cref="F:System.Int32.MinValue"/>
            to
            <see cref="F:System.Int32.MaxValue"/>
            (inclusive).</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Misc.IntervalSet.intervals">
            <summary>The list of sorted, disjoint intervals.</summary>
            <remarks>The list of sorted, disjoint intervals.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Of(System.Int32)">
            <summary>Create a set with a single element, el.</summary>
            <remarks>Create a set with a single element, el.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Of(System.Int32,System.Int32)">
            <summary>Create a set with all ints within range [a..b] (inclusive)</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Add(System.Int32)">
            <summary>Add a single element to the set.</summary>
            <remarks>
            Add a single element to the set.  An isolated element is stored
            as a range el..el.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Add(System.Int32,System.Int32)">
            <summary>Add interval; i.e., add all integers from a to b to set.</summary>
            <remarks>
            Add interval; i.e., add all integers from a to b to set.
            If b&lt;a, do nothing.
            Keep list in sorted order (by left range value).
            If overlap, combine ranges.  For example,
            If this is {1..5, 10..20}, adding 6..7 yields
            {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Or(Antlr4.Runtime.Misc.IntervalSet[])">
            <summary>combine all sets in the array returned the or'd value</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Complement(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            <inheritDoc/>
            
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Subtract(Antlr4.Runtime.Misc.IntervalSet,Antlr4.Runtime.Misc.IntervalSet)">
            <summary>Compute the set difference between two interval sets.</summary>
            <remarks>
            Compute the set difference between two interval sets. The specific
            operation is
            <code>left - right</code>
            . If either of the input sets is
            <code>null</code>
            , it is treated as though it was an empty set.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.And(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            <inheritDoc/>
            
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Contains(System.Int32)">
            <summary>
            <inheritDoc/>
            
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.GetIntervals">
            <summary>Return a list of Interval objects.</summary>
            <remarks>Return a list of Interval objects.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Equals(System.Object)">
            <summary>
            Are two IntervalSets equal?  Because all intervals are sorted
            and disjoint, equals is a simple linear walk over both lists
            to make sure they are the same.
            </summary>
            <remarks>
            Are two IntervalSets equal?  Because all intervals are sorted
            and disjoint, equals is a simple linear walk over both lists
            to make sure they are the same.  Interval.equals() is used
            by the List.equals() method to check the ranges.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.IsNil">
            <summary>
            <inheritDoc/>
            
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.SingleElement">
            <summary>
            <inheritDoc/>
            
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.MaxElement">
            <summary>Returns the maximum value contained in the set.</summary>
            <remarks>Returns the maximum value contained in the set.</remarks>
            <returns>
            the maximum value contained in the set. If the set is empty, this
            method returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.MinElement">
            <summary>Returns the minimum value contained in the set.</summary>
            <remarks>Returns the minimum value contained in the set.</remarks>
            <returns>
            the minimum value contained in the set. If the set is empty, this
            method returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Misc.ParseCanceledException">
            <summary>This exception is thrown to cancel a parsing operation.</summary>
            <remarks>
            This exception is thrown to cancel a parsing operation. This exception does
            not extend
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            , allowing it to bypass the standard
            error recovery mechanisms.
            <see cref="T:Antlr4.Runtime.BailErrorStrategy"/>
            throws this exception in
            response to a parse error.
            </remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Misc.RuleDependencyChecker">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Utils.ToMap(System.String[])">
            <summary>Convert array of strings to string&#x2192;index map.</summary>
            <remarks>
            Convert array of strings to string&#x2192;index map. Useful for
            converting rulenames to name&#x2192;ruleindex map.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.NoViableAltException">
            <summary>
            Indicates that the parser could not decide which of two or more paths
            to take based upon the remaining input.
            </summary>
            <remarks>
            Indicates that the parser could not decide which of two or more paths
            to take based upon the remaining input. It tracks the starting token
            of the offending input and also knows where the parser was
            in the various paths when the error. Reported by reportNoViableAlternative()
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.NoViableAltException.deadEndConfigs">
            <summary>Which configurations did we try at input.index() that couldn't match input.LT(1)?</summary>
        </member>
        <member name="F:Antlr4.Runtime.NoViableAltException.startToken">
            <summary>
            The token object at the start index; the input stream might
            not be buffering tokens so get a reference to it.
            </summary>
            <remarks>
            The token object at the start index; the input stream might
            not be buffering tokens so get a reference to it. (At the
            time the error occurred, of course the stream needs to keep a
            buffer all of the tokens but later we might not have access to those.)
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Parser">
            <summary>This is all the parsing support code essentially; most of it is error recovery stuff.</summary>
            <remarks>This is all the parsing support code essentially; most of it is error recovery stuff.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Parser.bypassAltsAtnCache">
            <summary>
            This field maps from the serialized ATN string to the deserialized
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            with
            bypass alternatives.
            </summary>
            <seealso cref="P:Antlr4.Runtime.Atn.ATNDeserializationOptions.GenerateRuleBypassTransitions"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._errHandler">
            <summary>The error handling strategy for the parser.</summary>
            <remarks>
            The error handling strategy for the parser. The default value is a new
            instance of
            <see cref="T:Antlr4.Runtime.DefaultErrorStrategy"/>
            .
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.ErrorHandler"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._input">
            <summary>The input stream.</summary>
            <remarks>The input stream.</remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.InputStream"/>
            <seealso cref="M:Antlr4.Runtime.Parser.SetInputStream(Antlr4.Runtime.ITokenStream)"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._ctx">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            object for the currently executing rule.
            This is always non-null during the parsing process.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Parser._buildParseTrees">
            <summary>
            Specifies whether or not the parser should construct a parse tree during
            the parsing process.
            </summary>
            <remarks>
            Specifies whether or not the parser should construct a parse tree during
            the parsing process. The default value is
            <code>true</code>
            .
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.BuildParseTree"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._tracer">
            <summary>
            When
            <see cref="P:Antlr4.Runtime.Parser.Trace"/>
            <code>(true)</code>
            is called, a reference to the
            <see cref="T:Antlr4.Runtime.Parser.TraceListener"/>
            is stored here so it can be easily removed in a
            later call to
            <see cref="P:Antlr4.Runtime.Parser.Trace"/>
            <code>(false)</code>
            . The listener itself is
            implemented as a parser listener so this field is not directly used by
            other parser methods.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Parser._parseListeners">
            <summary>
            The list of
            <see cref="T:Antlr4.Runtime.Tree.IParseTreeListener"/>
            listeners registered to receive
            events during the parse.
            </summary>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._syntaxErrors">
            <summary>The number of syntax errors reported during parsing.</summary>
            <remarks>
            The number of syntax errors reported during parsing. This value is
            incremented each time
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            is called.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Reset">
            <summary>reset the parser's state</summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Match(System.Int32)">
            <summary>
            Match current input symbol against
            <code>ttype</code>
            . If the symbol type
            matches,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)"/>
            and
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            are
            called to complete the match process.
            <p>If the symbol type does not match,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is called on the current error
            strategy to attempt recovery. If
            <see cref="P:Antlr4.Runtime.Parser.BuildParseTree"/>
            is
            <code>true</code>
            and the token index of the symbol returned by
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is -1, the symbol is added to
            the parse tree by calling
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            .</p>
            </summary>
            <param name="ttype">the token type to match</param>
            <returns>the matched symbol</returns>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the current input symbol did not match
            <code>ttype</code>
            and the error strategy could not recover from the
            mismatched symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.MatchWildcard">
            <summary>Match current input symbol as a wildcard.</summary>
            <remarks>
            Match current input symbol as a wildcard. If the symbol type matches
            (i.e. has a value greater than 0),
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)"/>
            and
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            are called to complete the match process.
            <p>If the symbol type does not match,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is called on the current error
            strategy to attempt recovery. If
            <see cref="P:Antlr4.Runtime.Parser.BuildParseTree"/>
            is
            <code>true</code>
            and the token index of the symbol returned by
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is -1, the symbol is added to
            the parse tree by calling
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            .</p>
            </remarks>
            <returns>the matched symbol</returns>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the current input symbol did not match
            a wildcard and the error strategy could not recover from the mismatched
            symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">
            <summary>
            Registers
            <code>listener</code>
            to receive events during the parsing process.
            <p>To support output-preserving grammar transformations (including but not
            limited to left-recursion removal, automated left-factoring, and
            optimized code generation), calls to listener methods during the parse
            may differ substantially from calls made by
            <see cref="F:Antlr4.Runtime.Tree.ParseTreeWalker.Default"/>
            used after the parse is complete. In
            particular, rule entry and exit events may occur in a different order
            during the parse than after the parser. In addition, calls to certain
            rule entry methods may be omitted.</p>
            <p>With the following specific exceptions, calls to listener events are
            <em>deterministic</em>, i.e. for identical input the calls to listener
            methods will be the same.</p>
            <ul>
            <li>Alterations to the grammar used to generate code may change the
            behavior of the listener calls.</li>
            <li>Alterations to the command line options passed to ANTLR 4 when
            generating the parser may change the behavior of the listener calls.</li>
            <li>Changing the version of the ANTLR Tool used to generate the parser
            may change the behavior of the listener calls.</li>
            </ul>
            </summary>
            <param name="listener">the listener to add</param>
            <exception cref="T:System.ArgumentNullException">
            if
            <code/>
            listener is
            <code>null</code>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Parser.RemoveParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">
            <summary>
            Remove
            <code>listener</code>
            from the list of parse listeners.
            <p>If
            <code>listener</code>
            is
            <code>null</code>
            or has not been added as a parse
            listener, this method does nothing.</p>
            </summary>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
            <param name="listener">the listener to remove</param>
        </member>
        <member name="M:Antlr4.Runtime.Parser.RemoveParseListeners">
            <summary>Remove all parse listeners.</summary>
            <remarks>Remove all parse listeners.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.TriggerEnterRuleEvent">
            <summary>Notify any parse listeners of an enter rule event.</summary>
            <remarks>Notify any parse listeners of an enter rule event.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.TriggerExitRuleEvent">
            <summary>Notify any parse listeners of an exit rule event.</summary>
            <remarks>Notify any parse listeners of an exit rule event.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetATNWithBypassAlts">
            <summary>
            The ATN with bypass alternatives is expensive to create so we create it
            lazily.
            </summary>
            <remarks>
            The ATN with bypass alternatives is expensive to create so we create it
            lazily.
            </remarks>
            <exception cref="T:System.NotSupportedException">
            if the current parser does not
            implement the
            <see cref="P:Antlr4.Runtime.Recognizer`2.SerializedAtn"/>
            method.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Parser.CompileParseTreePattern(System.String,System.Int32)">
            <summary>The preferred method of getting a tree pattern.</summary>
            <remarks>
            The preferred method of getting a tree pattern. For example, here's a
            sample use:
            <pre>
            ParseTree t = parser.expr();
            ParseTreePattern p = parser.compileParseTreePattern("&lt;ID&gt;+0", MyParser.RULE_expr);
            ParseTreeMatch m = p.match(t);
            String id = m.get("ID");
            </pre>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.CompileParseTreePattern(System.String,System.Int32,Antlr4.Runtime.Lexer)">
            <summary>
            The same as
            <see cref="M:Antlr4.Runtime.Parser.CompileParseTreePattern(System.String,System.Int32)"/>
            but specify a
            <see cref="T:Antlr4.Runtime.Lexer"/>
            rather than trying to deduce it from this parser.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.SetInputStream(Antlr4.Runtime.ITokenStream)">
            <summary>Set the token stream and reset the parser.</summary>
            <remarks>Set the token stream and reset the parser.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Consume">
            <summary>
            Consume and return the
            <linkplain>
            #getCurrentToken
            current symbol
            </linkplain>
            .
            <p>E.g., given the following input with
            <code>A</code>
            being the current
            lookahead symbol, this function moves the cursor to
            <code>B</code>
            and returns
            <code>A</code>
            .</p>
            <pre>
            A B
            ^
            </pre>
            If the parser is not in error recovery mode, the consumed symbol is added
            to the parse tree using
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.IToken)"/>
            , and
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)"/>
            is called on any parse listeners.
            If the parser <em>is</em> in error recovery mode, the consumed symbol is
            added to the parse tree using
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            , and
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)"/>
            is called on any parse
            listeners.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.EnterRule(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>Always called by generated parsers upon entry to a rule.</summary>
            <remarks>
            Always called by generated parsers upon entry to a rule. Access field
            <see cref="F:Antlr4.Runtime.Parser._ctx"/>
            get the current context.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.PushNewRecursionContext(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>
            Like
            <see cref="M:Antlr4.Runtime.Parser.EnterRule(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)"/>
            but for recursive rules.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.IsExpectedToken(System.Int32)">
            <summary>
            Checks whether or not
            <code>symbol</code>
            can follow the current state in the
            ATN. The behavior of this method is equivalent to the following, but is
            implemented such that the complete context-sensitive follow set does not
            need to be explicitly constructed.
            <pre>
            return getExpectedTokens().contains(symbol);
            </pre>
            </summary>
            <param name="symbol">the symbol type to check</param>
            <returns>
            
            <code>true</code>
            if
            <code>symbol</code>
            can follow the current state in
            the ATN, otherwise
            <code>false</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetExpectedTokens">
            <summary>
            Computes the set of input symbols which could follow the current parser
            state and context, as given by
            <see cref="P:Antlr4.Runtime.Recognizer`2.State"/>
            and
            <see cref="P:Antlr4.Runtime.Parser.Context"/>
            ,
            respectively.
            </summary>
            <seealso cref="M:Antlr4.Runtime.Atn.ATN.GetExpectedTokens(System.Int32,Antlr4.Runtime.RuleContext)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetRuleIndex(System.String)">
            <summary>
            Get a rule's index (i.e.,
            <code>RULE_ruleName</code>
            field) or -1 if not found.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetRuleInvocationStack">
            <summary>
            Return List&lt;String&gt; of the rule names in your parser instance
            leading up to a call to the current rule.
            </summary>
            <remarks>
            Return List&lt;String&gt; of the rule names in your parser instance
            leading up to a call to the current rule.  You could override if
            you want more details such as the file/line info of where
            in the ATN a rule is invoked.
            This is very useful for error messages.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetDFAStrings">
            <summary>For debugging and other purposes.</summary>
            <remarks>For debugging and other purposes.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.DumpDFA">
            <summary>For debugging and other purposes.</summary>
            <remarks>For debugging and other purposes.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Parser.BuildParseTree">
            <summary>
            Track the
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            objects during the parse and hook
            them up using the
            <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
            list so that it
            forms a parse tree. The
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            returned from the start
            rule represents the root of the parse tree.
            <p>Note that if we are not building parse trees, rule contexts only point
            upwards. When a rule exits, it returns the context but that gets garbage
            collected if nobody holds a reference. It points upwards but nobody
            points at it.</p>
            <p>When we build parse trees, we are adding all of these contexts to
            <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
            list. Contexts are then not candidates
            for garbage collection.</p>
            </summary>
            <summary>
            Gets whether or not a complete parse tree will be constructed while
            parsing.
            </summary>
            <remarks>
            Gets whether or not a complete parse tree will be constructed while
            parsing. This property is
            <code>true</code>
            for a newly constructed parser.
            </remarks>
            <returns>
            
            <code>true</code>
            if a complete parse tree will be constructed while
            parsing, otherwise
            <code>false</code>
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Parser.TrimParseTree">
            <summary>Trim the internal lists of the parse tree during parsing to conserve memory.</summary>
            <remarks>
            Trim the internal lists of the parse tree during parsing to conserve memory.
            This property is set to
            <code>false</code>
            by default for a newly constructed parser.
            </remarks>
            <value>
            
            <code>true</code>
            to trim the capacity of the
            <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
            list to its size after a rule is parsed.
            </value>
            <returns>
            
            <code>true</code>
            if the
            <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
            list is trimmed
            using the default
            <see cref="T:Antlr4.Runtime.Parser.TrimToSizeListener"/>
            during the parse process.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Parser.NumberOfSyntaxErrors">
            <summary>Gets the number of syntax errors reported during parsing.</summary>
            <remarks>
            Gets the number of syntax errors reported during parsing. This value is
            incremented each time
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            is called.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
        </member>
        <member name="P:Antlr4.Runtime.Parser.CurrentToken">
            <summary>
            Match needs to return the current input symbol, which gets put
            into the label for the associated token ref; e.g., x=ID.
            </summary>
            <remarks>
            Match needs to return the current input symbol, which gets put
            into the label for the associated token ref; e.g., x=ID.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Parser.Precedence">
            <summary>Get the precedence level for the top-most precedence rule.</summary>
            <remarks>Get the precedence level for the top-most precedence rule.</remarks>
            <returns>
            The precedence level for the top-most precedence rule, or -1 if
            the parser context is not nested within a precedence rule.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Parser.Profile">
            <since>4.3</since>
        </member>
        <member name="P:Antlr4.Runtime.Parser.Trace">
            <summary>
            During a parse is sometimes useful to listen in on the rule entry and exit
            events as well as token matches.
            </summary>
            <remarks>
            During a parse is sometimes useful to listen in on the rule entry and exit
            events as well as token matches. This is for quick and dirty debugging.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.ParserInterpreter">
            <summary>
            A parser simulator that mimics what ANTLR's generated
            parser code does.
            </summary>
            <remarks>
            A parser simulator that mimics what ANTLR's generated
            parser code does. A ParserATNSimulator is used to make
            predictions via adaptivePredict but this class moves a pointer through the
            ATN to simulate parsing. ParserATNSimulator just
            makes us efficient rather than having to backtrack, for example.
            This properly creates parse trees even for left recursive rules.
            We rely on the left recursive rule invocation and special predicate
            transitions to make left recursive rules work.
            See TestParserInterpreter for examples.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserInterpreter.Parse(System.Int32)">
            <summary>Begin parsing at startRuleIndex</summary>
        </member>
        <member name="T:Antlr4.Runtime.ProxyErrorListener`1">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            dispatches all calls to a
            collection of delegate listeners. This reduces the effort required to support multiple
            listeners.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.ProxyParserErrorListener">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.TokenStreamRewriter">
            <summary>
            Useful for rewriting out a buffered input token stream after doing some
            augmentation or other manipulations on it.
            </summary>
            <remarks>
            Useful for rewriting out a buffered input token stream after doing some
            augmentation or other manipulations on it.
            <p>
            You can insert stuff, replace, and delete chunks. Note that the operations
            are done lazily--only if you convert the buffer to a
            <see cref="T:System.String"/>
            with
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText"/>
            . This is very efficient because you are not
            moving data around all the time. As the buffer of tokens is converted to
            strings, the
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            method(s) scan the input token stream and
            check to see if there is an operation at the current index. If so, the
            operation is done and then normal
            <see cref="T:System.String"/>
            rendering continues on the
            buffer. This is like having multiple Turing machine instruction streams
            (programs) operating on a single input tape. :)</p>
            <p>
            This rewriter makes no modifications to the token stream. It does not ask the
            stream to fill itself up nor does it advance the input cursor. The token
            stream
            <see cref="P:Antlr4.Runtime.IIntStream.Index"/>
            will return the same value before and
            after any
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            call.</p>
            <p>
            The rewriter only works on tokens that you have in the buffer and ignores the
            current input cursor. If you are buffering tokens on-demand, calling
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            halfway through the input will only do rewrites for those
            tokens in the first half of the file.</p>
            <p>
            Since the operations are done lazily at
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            -time, operations do
            not screw up the token index values. That is, an insert operation at token
            index
            <code>i</code>
            does not change the index values for tokens
            <code>i</code>
            +1..n-1.</p>
            <p>
            Because operations never actually alter the buffer, you may always get the
            original token stream back without undoing anything. Since the instructions
            are queued up, you can easily simulate transactions and roll back any changes
            if there is an error just by removing instructions. For example,</p>
            <pre>
            CharStream input = new ANTLRFileStream("input");
            TLexer lex = new TLexer(input);
            CommonTokenStream tokens = new CommonTokenStream(lex);
            T parser = new T(tokens);
            TokenStreamRewriter rewriter = new TokenStreamRewriter(tokens);
            parser.startRule();
            </pre>
            <p>
            Then in the rules, you can execute (assuming rewriter is visible):</p>
            <pre>
            Token t,u;
            ...
            rewriter.insertAfter(t, "text to put after t");}
            rewriter.insertAfter(u, "text after u");}
            System.out.println(tokens.toString());
            </pre>
            <p>
            You can also have multiple "instruction streams" and get multiple rewrites
            from a single pass over the input. Just name the instruction streams and use
            that name again when printing the buffer. This could be useful for generating
            a C file and also its header file--all from the same buffer:</p>
            <pre>
            tokens.insertAfter("pass1", t, "text to put after t");}
            tokens.insertAfter("pass2", u, "text after u");}
            System.out.println(tokens.toString("pass1"));
            System.out.println(tokens.toString("pass2"));
            </pre>
            <p>
            If you don't use named rewrite streams, a "default" stream is used as the
            first example shows.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.tokens">
            <summary>Our source stream</summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.programs">
            <summary>You may have multiple, named streams of rewrite operations.</summary>
            <remarks>
            You may have multiple, named streams of rewrite operations.
            I'm calling these things "programs."
            Maps String (name) &#x2192; rewrite (List)
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.lastRewriteTokenIndexes">
            <summary>Map String (program name) &#x2192; Integer index</summary>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.Rollback(System.String,System.Int32)">
            <summary>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream.
            </summary>
            <remarks>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream.  UNTESTED!
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.DeleteProgram(System.String)">
            <summary>Reset the program so that no instructions exist</summary>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetText">
            <summary>
            Return the text from the original tokens altered per the
            instructions given to this rewriter.
            </summary>
            <remarks>
            Return the text from the original tokens altered per the
            instructions given to this rewriter.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the text associated with the tokens in the interval from the
            original token stream but with the alterations given to this rewriter.
            </summary>
            <remarks>
            Return the text associated with the tokens in the interval from the
            original token stream but with the alterations given to this rewriter.
            The interval refers to the indexes in the original token stream.
            We do not alter the token stream in any way, so the indexes
            and intervals are still consistent. Includes any operations done
            to the first and last token in the interval. So, if you did an
            insertBefore on the first token, you would get that insertion.
            The same is true if you do an insertAfter the stop token.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.ReduceToSingleOperationPerIndex(System.Collections.Generic.IList{Antlr4.Runtime.TokenStreamRewriter.RewriteOperation})">
            <summary>
            We need to combine operations and report invalid operations (like
            overlapping replaces that are not completed nested).
            </summary>
            <remarks>
            We need to combine operations and report invalid operations (like
            overlapping replaces that are not completed nested).  Inserts to
            same index need to be combined etc...   Here are the cases:
            I.i.u I.j.v								leave alone, nonoverlapping
            I.i.u I.i.v								combine: Iivu
            R.i-j.u R.x-y.v	| i-j in x-y			delete first R
            R.i-j.u R.i-j.v							delete first R
            R.i-j.u R.x-y.v	| x-y in i-j			ERROR
            R.i-j.u R.x-y.v	| boundaries overlap	ERROR
            Delete special case of replace (text==null):
            D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
            I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
            we're not deleting i)
            I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
            R.x-y.v I.i.u | i in x-y				ERROR
            R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
            R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
            I.i.u = insert u before op @ index i
            R.x-y.u = replace x-y indexed tokens with u
            First we need to examine replaces.  For any replace op:
            1. wipe out any insertions before op within that range.
            2. Drop any replace op before that is contained completely within
            that range.
            3. Throw exception upon boundary overlap with any previous replace.
            Then we can deal with inserts:
            1. for any inserts to same index, combine even if not adjacent.
            2. for any prior replace with same left boundary, combine this
            insert with replace and delete this replace.
            3. throw exception if index in same range as previous replace
            Don't actually delete; make op null in list. Easier to walk list.
            Later we can throw as we add to index &#x2192; op map.
            Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
            inserted stuff would be before the replace range.  But, if you
            add tokens in front of a method body '{' and then delete the method
            body, I think the stuff before the '{' you added should disappear too.
            Return a map from token index to operation.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetKindOfOps``1(System.Collections.Generic.IList{Antlr4.Runtime.TokenStreamRewriter.RewriteOperation},System.Int32)">
            <summary>Get all operations before an index of a particular kind</summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.instructionIndex">
            <summary>What index into rewrites List are we?</summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.index">
            <summary>Token buffer index.</summary>
            <remarks>Token buffer index.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.Execute(System.Text.StringBuilder)">
            <summary>Execute the rewrite operation by possibly adding to the buffer.</summary>
            <remarks>
            Execute the rewrite operation by possibly adding to the buffer.
            Return the index of the next token to operate on.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.TokenStreamRewriter.ReplaceOp">
            <summary>
            I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
            instructions.
            </summary>
            <remarks>
            I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
            instructions.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.IParseTreeVisitor`1">
            <summary>This interface defines the basic notion of a parse tree visitor.</summary>
            <remarks>
            This interface defines the basic notion of a parse tree visitor. Generated
            visitors implement this interface and the
            <code>XVisitor</code>
            interface for
            grammar
            <code>X</code>
            .
            </remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.Visit(Antlr4.Runtime.Tree.IParseTree)">
            <summary>Visit a parse tree, and return a user-defined result of the operation.</summary>
            <remarks>Visit a parse tree, and return a user-defined result of the operation.</remarks>
            <param name="tree">
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            to visit.
            </param>
            <returns>The result of visiting the parse tree.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            Visit the children of a node, and return a user-defined result
            of the operation.
            </summary>
            <remarks>
            Visit the children of a node, and return a user-defined result
            of the operation.
            </remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.IRuleNode"/>
            whose children should be visited.
            </param>
            <returns>The result of visiting the children of the node.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>Visit a terminal node, and return a user-defined result of the operation.</summary>
            <remarks>Visit a terminal node, and return a user-defined result of the operation.</remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.ITerminalNode"/>
            to visit.
            </param>
            <returns>The result of visiting the node.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <summary>Visit an error node, and return a user-defined result of the operation.</summary>
            <remarks>Visit an error node, and return a user-defined result of the operation.</remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.IErrorNode"/>
            to visit.
            </param>
            <returns>The result of visiting the node.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.Visit(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            <inheritDoc/>
            <p>The default implementation calls
            <see cref="M:Antlr4.Runtime.Tree.IParseTree.Accept``1(Antlr4.Runtime.Tree.IParseTreeVisitor{``0})"/>
            on the
            specified tree.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            <inheritDoc/>
            <p>The default implementation initializes the aggregate result to
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult()</see>
            . Before visiting each child, it
            calls
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)">shouldVisitNextChild</see>
            ; if the result
            is
            <code>false</code>
            no more children are visited and the current aggregate
            result is returned. After visiting a child, the aggregate result is
            updated by calling
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.AggregateResult(`0,`0)">aggregateResult</see>
            with the
            previous aggregate result and the result of visiting the child.</p>
            <p>The default implementation is not safe for use in visitors that modify
            the tree structure. Visitors that modify the tree should override this
            method to behave properly in respect to the specific algorithm in use.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>
            <inheritDoc/>
            <p>The default implementation returns the result of
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult</see>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <summary>
            <inheritDoc/>
            <p>The default implementation returns the result of
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult</see>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.AggregateResult(`0,`0)">
            <summary>Aggregates the results of visiting multiple children of a node.</summary>
            <remarks>
            Aggregates the results of visiting multiple children of a node. After
            either all children are visited or
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)"/>
            returns
            <code>false</code>
            , the aggregate value is returned as the result of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            .
            <p>The default implementation returns
            <code>nextResult</code>
            , meaning
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            will return the result of the last child visited
            (or return the initial value if the node has no children).</p>
            </remarks>
            <param name="aggregate">
            The previous aggregate value. In the default
            implementation, the aggregate value is initialized to
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult"/>
            , which is passed as the
            <code>aggregate</code>
            argument
            to this method after the first child node is visited.
            </param>
            <param name="nextResult">
            The result of the immediately preceeding call to visit
            a child node.
            </param>
            <returns>The updated aggregate result.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)">
            <summary>
            This method is called after visiting each child in
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            . This method is first called before the first
            child is visited; at that point
            <code>currentResult</code>
            will be the initial
            value (in the default implementation, the initial value is returned by a
            call to
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult"/>
            . This method is not called after the last
            child is visited.
            <p>The default implementation always returns
            <code>true</code>
            , indicating that
            <code>visitChildren</code>
            should only return after all children are visited.
            One reason to override this method is to provide a "short circuit"
            evaluation option for situations where the result of visiting a single
            child has the potential to determine the result of the visit operation as
            a whole.</p>
            </summary>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.IRuleNode"/>
            whose children are currently being
            visited.
            </param>
            <param name="currentResult">
            The current aggregate result of the children visited
            to the current point.
            </param>
            <returns>
            
            <code>true</code>
            to continue visiting children. Otherwise return
            <code>false</code>
            to stop visiting children and immediately return the
            current aggregate result from
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">
            <summary>Gets the default value returned by visitor methods.</summary>
            <remarks>
            Gets the default value returned by visitor methods. This value is
            returned by the default implementations of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">visitTerminal</see>
            ,
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">visitErrorNode</see>
            .
            The default implementation of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">visitChildren</see>
            initializes its aggregate result to this value.
            <p>The base implementation returns
            <code>null</code>
            .</p>
            </remarks>
            <returns>The default value returned by visitor methods.</returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ErrorNodeImpl">
            <summary>
            Represents a token that was consumed during resynchronization
            rather than during a valid match operation.
            </summary>
            <remarks>
            Represents a token that was consumed during resynchronization
            rather than during a valid match operation. For example,
            we will create this kind of a node during single token insertion
            and deletion as well as during "consume until error recovery set"
            upon no viable alternative exceptions.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ParseTreeProperty`1">
            <summary>Associate a property with a parse tree node.</summary>
            <remarks>
            Associate a property with a parse tree node. Useful with parse tree listeners
            that need to associate values with particular tree nodes, kind of like
            specifying a return value for the listener event method that visited a
            particular node. Example:
            <pre>
            ParseTreeProperty&lt;Integer&gt; values = new ParseTreeProperty&lt;Integer&gt;();
            values.put(tree, 36);
            int x = values.get(tree);
            values.removeFrom(tree);
            </pre>
            You would make one decl (values here) in the listener and use lots of times
            in your event methods.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ParseTreeWalker.EnterRule(Antlr4.Runtime.Tree.IParseTreeListener,Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            The discovery of a rule node, involves sending two events: the generic
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.EnterEveryRule(Antlr4.Runtime.ParserRuleContext)"/>
            and a
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            -specific event. First we trigger the generic and then
            the rule specific. We to them in reverse order upon finishing the node.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.Chunk">
            <summary>
            A chunk is either a token tag, a rule tag, or a span of literal text within a
            tree pattern.
            </summary>
            <remarks>
            A chunk is either a token tag, a rule tag, or a span of literal text within a
            tree pattern.
            <p>The method
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Split(System.String)"/>
            returns a list of
            chunks in preparation for creating a token stream by
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Tokenize(System.String)"/>
            . From there, we get a parse
            tree from with
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Compile(System.String,System.Int32)"/>
            . These
            chunks are converted to
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            ,
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            , or the
            regular tokens of the text surrounding the tags.</p>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch">
            <summary>
            Represents the result of matching a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            against a tree pattern.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.tree">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Tree"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.pattern">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Pattern"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.labels">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Labels"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.mismatchedNode">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.MismatchedNode"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.#ctor(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern,Antlr4.Runtime.Misc.MultiMap{System.String,Antlr4.Runtime.Tree.IParseTree},Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            from the specified
            parse tree and pattern.
            </summary>
            <param name="tree">The parse tree to match against the pattern.</param>
            <param name="pattern">The parse tree pattern.</param>
            <param name="labels">
            A mapping from label names to collections of
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            objects located by the tree pattern matching process.
            </param>
            <param name="mismatchedNode">
            The first node which failed to match the tree
            pattern during the matching process.
            </param>
            <exception>
            IllegalArgumentException
            if
            <code>tree</code>
            is
            <code>null</code>
            </exception>
            <exception>
            IllegalArgumentException
            if
            <code>pattern</code>
            is
            <code>null</code>
            </exception>
            <exception>
            IllegalArgumentException
            if
            <code>labels</code>
            is
            <code>null</code>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Get(System.String)">
            <summary>
            Get the last node associated with a specific
            <code>label</code>
            .
            <p>For example, for pattern
            <code>&lt;id:ID&gt;</code>
            ,
            <code>get("id")</code>
            returns the
            node matched for that
            <code>ID</code>
            . If more than one node
            matched the specified label, only the last is returned. If there is
            no node associated with the label, this returns
            <code>null</code>
            .</p>
            <p>Pattern tags like
            <code>&lt;ID&gt;</code>
            and
            <code>&lt;expr&gt;</code>
            without labels are
            considered to be labeled with
            <code>ID</code>
            and
            <code>expr</code>
            , respectively.</p>
            </summary>
            <param name="label">The label to check.</param>
            <returns>
            The last
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            to match a tag with the specified
            label, or
            <code>null</code>
            if no parse tree matched a tag with the label.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.GetAll(System.String)">
            <summary>Return all nodes matching a rule or token tag with the specified label.</summary>
            <remarks>
            Return all nodes matching a rule or token tag with the specified label.
            <p>If the
            <code>label</code>
            is the name of a parser rule or token in the
            grammar, the resulting list will contain both the parse trees matching
            rule or tags explicitly labeled with the label and the complete set of
            parse trees matching the labeled and unlabeled tags in the pattern for
            the parser rule or token. For example, if
            <code>label</code>
            is
            <code>"foo"</code>
            ,
            the result will contain <em>all</em> of the following.</p>
            <ul>
            <li>Parse tree nodes matching tags of the form
            <code>&lt;foo:anyRuleName&gt;</code>
            and
            <code>&lt;foo:AnyTokenName&gt;</code>
            .</li>
            <li>Parse tree nodes matching tags of the form
            <code>&lt;anyLabel:foo&gt;</code>
            .</li>
            <li>Parse tree nodes matching tags of the form
            <code>&lt;foo&gt;</code>
            .</li>
            </ul>
            </remarks>
            <param name="label">The label.</param>
            <returns>
            A collection of all
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            nodes matching tags with
            the specified
            <code>label</code>
            . If no nodes matched the label, an empty list
            is returned.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.ToString">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Labels">
            <summary>Return a mapping from label â [list of nodes].</summary>
            <remarks>
            Return a mapping from label â [list of nodes].
            <p>The map includes special entries corresponding to the names of rules and
            tokens referenced in tags in the original pattern. For additional
            information, see the description of
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.GetAll(System.String)"/>
            .</p>
            </remarks>
            <returns>
            A mapping from labels to parse tree nodes. If the parse tree
            pattern did not contain any rule or token tags, this map will be empty.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.MismatchedNode">
            <summary>Get the node at which we first detected a mismatch.</summary>
            <remarks>Get the node at which we first detected a mismatch.</remarks>
            <returns>
            the node at which we first detected a mismatch, or
            <code>null</code>
            if the match was successful.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Succeeded">
            <summary>Gets a value indicating whether the match operation succeeded.</summary>
            <remarks>Gets a value indicating whether the match operation succeeded.</remarks>
            <returns>
            
            <code>true</code>
            if the match operation succeeded; otherwise,
            <code>false</code>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Pattern">
            <summary>Get the tree pattern we are matching against.</summary>
            <remarks>Get the tree pattern we are matching against.</remarks>
            <returns>The tree pattern we are matching against.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Tree">
            <summary>Get the parse tree we are trying to match to a pattern.</summary>
            <remarks>Get the parse tree we are trying to match to a pattern.</remarks>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            we are trying to match to a pattern.
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern">
            <summary>
            A pattern like
            <code>&lt;ID&gt; = &lt;expr&gt;;</code>
            converted to a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            by
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Compile(System.String,System.Int32)"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.patternRuleIndex">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternRuleIndex"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.pattern">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Pattern"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.patternTree">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternTree"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.matcher">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Matcher"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.#ctor(Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher,System.String,System.Int32,Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Construct a new instance of the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            class.
            </summary>
            <param name="matcher">
            The
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            which created this
            tree pattern.
            </param>
            <param name="pattern">The tree pattern in concrete syntax form.</param>
            <param name="patternRuleIndex">
            The parser rule which serves as the root of the
            tree pattern.
            </param>
            <param name="patternTree">
            The tree pattern in
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            form.
            </param>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Match(Antlr4.Runtime.Tree.IParseTree)">
            <summary>Match a specific parse tree against this tree pattern.</summary>
            <remarks>Match a specific parse tree against this tree pattern.</remarks>
            <param name="tree">The parse tree to match against this tree pattern.</param>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object describing the result of the
            match operation. The
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Succeeded"/>
            method can be
            used to determine whether or not the match was successful.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Matches(Antlr4.Runtime.Tree.IParseTree)">
            <summary>Determine whether or not a parse tree matches this tree pattern.</summary>
            <remarks>Determine whether or not a parse tree matches this tree pattern.</remarks>
            <param name="tree">The parse tree to match against this tree pattern.</param>
            <returns>
            
            <code>true</code>
            if
            <code>tree</code>
            is a match for the current tree
            pattern; otherwise,
            <code>false</code>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.FindAll(Antlr4.Runtime.Tree.IParseTree,System.String)">
            <summary>
            Find all nodes using XPath and then try to match those subtrees against
            this tree pattern.
            </summary>
            <remarks>
            Find all nodes using XPath and then try to match those subtrees against
            this tree pattern.
            </remarks>
            <param name="tree">
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            to match against this pattern.
            </param>
            <param name="xpath">An expression matching the nodes</param>
            <returns>
            A collection of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            objects describing the
            successful matches. Unsuccessful matches are omitted from the result,
            regardless of the reason for the failure.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Matcher">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            which created this tree pattern.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            which created this tree
            pattern.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Pattern">
            <summary>Get the tree pattern in concrete syntax form.</summary>
            <remarks>Get the tree pattern in concrete syntax form.</remarks>
            <returns>The tree pattern in concrete syntax form.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternRuleIndex">
            <summary>
            Get the parser rule which serves as the outermost rule for the tree
            pattern.
            </summary>
            <remarks>
            Get the parser rule which serves as the outermost rule for the tree
            pattern.
            </remarks>
            <returns>
            The parser rule which serves as the outermost rule for the tree
            pattern.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternTree">
            <summary>
            Get the tree pattern as a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            . The rule and token tags from
            the pattern are present in the parse tree as terminal nodes with a symbol
            of type
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            or
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            .
            </summary>
            <returns>
            The tree pattern as a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher">
            <summary>
            A tree pattern matching mechanism for ANTLR
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            s.
            <p>Patterns are strings of source input text with special tags representing
            token or rule references such as:</p>
            <p>
            <code>&lt;ID&gt; = &lt;expr&gt;;</code>
            </p>
            <p>Given a pattern start rule such as
            <code>statement</code>
            , this object constructs
            a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            with placeholders for the
            <code>ID</code>
            and
            <code>expr</code>
            subtree. Then the
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)"/>
            routines can compare an actual
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            from a parse with this pattern. Tag
            <code>&lt;ID&gt;</code>
            matches
            any
            <code>ID</code>
            token and tag
            <code>&lt;expr&gt;</code>
            references the result of the
            <code>expr</code>
            rule (generally an instance of
            <code>ExprContext</code>
            .</p>
            <p>Pattern
            <code>x = 0;</code>
            is a similar pattern that matches the same pattern
            except that it requires the identifier to be
            <code>x</code>
            and the expression to
            be
            <code>0</code>
            .</p>
            <p>The
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Matches(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)"/>
            routines return
            <code>true</code>
            or
            <code>false</code>
            based
            upon a match for the tree rooted at the parameter sent in. The
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)"/>
            routines return a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object that
            contains the parse tree, the parse tree pattern, and a map from tag name to
            matched nodes (more below). A subtree that fails to match, returns with
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.MismatchedNode"/>
            set to the first tree node that did not
            match.</p>
            <p>For efficiency, you can compile a tree pattern in string form to a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            object.</p>
            <p>See
            <code>TestParseTreeMatcher</code>
            for lots of examples.
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            has two static helper methods:
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.FindAll(Antlr4.Runtime.Tree.IParseTree,System.String)"/>
            and
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Match(Antlr4.Runtime.Tree.IParseTree)"/>
            that
            are easy to use but not super efficient because they create new
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            objects each time and have to compile the
            pattern in string form before using it.</p>
            <p>The lexer and parser that you pass into the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            constructor are used to parse the pattern in string form. The lexer converts
            the
            <code>&lt;ID&gt; = &lt;expr&gt;;</code>
            into a sequence of four tokens (assuming lexer
            throws out whitespace or puts it on a hidden channel). Be aware that the
            input stream is reset for the lexer (but not the parser; a
            <see cref="T:Antlr4.Runtime.ParserInterpreter"/>
            is created to parse the input.). Any user-defined
            fields you have put into the lexer might get changed when this mechanism asks
            it to scan the pattern string.</p>
            <p>Normally a parser does not accept token
            <code>&lt;expr&gt;</code>
            as a valid
            <code>expr</code>
            but, from the parser passed in, we create a special version of
            the underlying grammar representation (an
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            ) that allows imaginary
            tokens representing rules (
            <code>&lt;expr&gt;</code>
            ) to match entire rules. We call
            these <em>bypass alternatives</em>.</p>
            <p>Delimiters are
            <code>&lt;</code>
            and
            <code>&gt;</code>
            , with
            <code>\</code>
            as the escape string
            by default, but you can set them to whatever you want using
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.SetDelimiters(System.String,System.String,System.String)"/>
            . You must escape both start and stop strings
            <code>\&lt;</code>
            and
            <code>\&gt;</code>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.lexer">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Lexer"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.parser">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Parser"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.#ctor(Antlr4.Runtime.Lexer,Antlr4.Runtime.Parser)">
            <summary>
            Constructs a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            or from a
            <see cref="T:Antlr4.Runtime.Lexer"/>
            and
            <see cref="T:Antlr4.Runtime.Parser"/>
            object. The lexer input stream is altered for tokenizing
            the tree patterns. The parser is used as a convenient mechanism to get
            the grammar name, plus token, rule names.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.SetDelimiters(System.String,System.String,System.String)">
            <summary>
            Set the delimiters used for marking rule and token tags within concrete
            syntax used by the tree pattern parser.
            </summary>
            <remarks>
            Set the delimiters used for marking rule and token tags within concrete
            syntax used by the tree pattern parser.
            </remarks>
            <param name="start">The start delimiter.</param>
            <param name="stop">The stop delimiter.</param>
            <param name="escapeLeft">The escape sequence to use for escaping a start or stop delimiter.</param>
            <exception>
            IllegalArgumentException
            if
            <code>start</code>
            is
            <code>null</code>
            or empty.
            </exception>
            <exception>
            IllegalArgumentException
            if
            <code>stop</code>
            is
            <code>null</code>
            or empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Matches(Antlr4.Runtime.Tree.IParseTree,System.String,System.Int32)">
            <summary>
            Does
            <code>pattern</code>
            matched as rule
            <code>patternRuleIndex</code>
            match
            <code>tree</code>
            ?
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Matches(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)">
            <summary>
            Does
            <code>pattern</code>
            matched as rule patternRuleIndex match tree? Pass in a
            compiled pattern instead of a string representation of a tree pattern.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,System.String,System.Int32)">
            <summary>
            Compare
            <code>pattern</code>
            matched as rule
            <code>patternRuleIndex</code>
            against
            <code>tree</code>
            and return a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object that contains the
            matched elements, or the node at which the match failed.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)">
            <summary>
            Compare
            <code>pattern</code>
            matched against
            <code>tree</code>
            and return a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object that contains the matched elements, or the
            node at which the match failed. Pass in a compiled pattern instead of a
            string representation of a tree pattern.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Compile(System.String,System.Int32)">
            <summary>
            For repeated use of a tree pattern, compile it to a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            using this method.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.MatchImpl(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Misc.MultiMap{System.String,Antlr4.Runtime.Tree.IParseTree})">
            <summary>
            Recursively walk
            <code>tree</code>
            against
            <code>patternTree</code>
            , filling
            <code>match.</code>
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Labels"/>
            .
            </summary>
            <returns>
            the first node encountered in
            <code>tree</code>
            which does not match
            a corresponding node in
            <code>patternTree</code>
            , or
            <code>null</code>
            if the match
            was successful. The specific node returned depends on the matching
            algorithm used by the implementation, and may be overridden.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.GetRuleTagToken(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Is
            <code>t</code>
            
            <code>(expr &lt;expr&gt;)</code>
            subtree?
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Split(System.String)">
            <summary>
            Split
            <code>&lt;ID&gt; = &lt;e:expr&gt; ;</code>
            into 4 chunks for tokenizing by
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Tokenize(System.String)"/>
            .
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Lexer">
            <summary>Used to convert the tree pattern string into a series of tokens.</summary>
            <remarks>
            Used to convert the tree pattern string into a series of tokens. The
            input stream is reset.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Parser">
            <summary>
            Used to collect to the grammar file name, token names, rule names for
            used to parse the pattern into a parse tree.
            </summary>
            <remarks>
            Used to collect to the grammar file name, token names, rule names for
            used to parse the pattern into a parse tree.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken">
            <summary>
            A
            <see cref="T:Antlr4.Runtime.IToken"/>
            object representing an entire subtree matched by a parser
            rule; e.g.,
            <code>&lt;expr&gt;</code>
            . These tokens are created for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            chunks where the tag corresponds to a parser rule.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.RuleTagToken.ruleName">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.RuleName"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.RuleTagToken.bypassTokenType">
            <summary>The token type for the current token.</summary>
            <remarks>
            The token type for the current token. This is the token type assigned to
            the bypass alternative for the rule during ATN deserialization.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.RuleTagToken.label">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Label"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.RuleTagToken.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            with the specified rule
            name and bypass token type and no label.
            </summary>
            <param name="ruleName">The name of the parser rule this rule tag matches.</param>
            <param name="bypassTokenType">The bypass token type assigned to the parser rule.</param>
            <exception>
            IllegalArgumentException
            if
            <code>ruleName</code>
            is
            <code>null</code>
            or empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.RuleTagToken.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            with the specified rule
            name, bypass token type, and label.
            </summary>
            <param name="ruleName">The name of the parser rule this rule tag matches.</param>
            <param name="bypassTokenType">The bypass token type assigned to the parser rule.</param>
            <param name="label">
            The label associated with the rule tag, or
            <code>null</code>
            if
            the rule tag is unlabeled.
            </param>
            <exception>
            IllegalArgumentException
            if
            <code>ruleName</code>
            is
            <code>null</code>
            or empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.RuleTagToken.ToString">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            returns a string of the form
            <code>ruleName:bypassTokenType</code>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.RuleName">
            <summary>Gets the name of the rule associated with this rule tag.</summary>
            <remarks>Gets the name of the rule associated with this rule tag.</remarks>
            <returns>The name of the parser rule associated with this rule tag.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Label">
            <summary>Gets the label associated with the rule tag.</summary>
            <remarks>Gets the label associated with the rule tag.</remarks>
            <returns>
            The name of the label associated with the rule tag, or
            <code>null</code>
            if this is an unlabeled rule tag.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Channel">
            <summary>
            <inheritDoc/>
            <p>Rule tag tokens are always placed on the
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Text">
            <summary>
            <inheritDoc/>
            <p>This method returns the rule tag formatted with
            <code>&lt;</code>
            and
            <code>&gt;</code>
            delimiters.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Type">
            <summary>
            <inheritDoc/>
            <p>Rule tag tokens have types assigned according to the rule bypass
            transitions created during ATN deserialization.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Line">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns 0.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Column">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.TokenIndex">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.StartIndex">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.StopIndex">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.TokenSource">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns
            <code>null</code>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.InputStream">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns
            <code>null</code>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.TagChunk">
            <summary>Represents a placeholder tag in a tree pattern.</summary>
            <remarks>
            Represents a placeholder tag in a tree pattern. A tag can have any of the
            following forms.
            <ul>
            <li>
            <code>expr</code>
            : An unlabeled placeholder for a parser rule
            <code>expr</code>
            .</li>
            <li>
            <code>ID</code>
            : An unlabeled placeholder for a token of type
            <code>ID</code>
            .</li>
            <li>
            <code>e:expr</code>
            : A labeled placeholder for a parser rule
            <code>expr</code>
            .</li>
            <li>
            <code>id:ID</code>
            : A labeled placeholder for a token of type
            <code>ID</code>
            .</li>
            </ul>
            This class does not perform any validation on the tag or label names aside
            from ensuring that the tag is a non-null, non-empty string.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TagChunk.tag">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Tag"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TagChunk.label">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Label"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TagChunk.#ctor(System.String)">
            <summary>
            Construct a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            using the specified tag and
            no label.
            </summary>
            <param name="tag">
            The tag, which should be the name of a parser rule or token
            type.
            </param>
            <exception>
            IllegalArgumentException
            if
            <code>tag</code>
            is
            <code>null</code>
            or
            empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TagChunk.#ctor(System.String,System.String)">
            <summary>
            Construct a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            using the specified label
            and tag.
            </summary>
            <param name="label">
            The label for the tag. If this is
            <code>null</code>
            , the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            represents an unlabeled tag.
            </param>
            <param name="tag">
            The tag, which should be the name of a parser rule or token
            type.
            </param>
            <exception>
            IllegalArgumentException
            if
            <code>tag</code>
            is
            <code>null</code>
            or
            empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TagChunk.ToString">
            <summary>This method returns a text representation of the tag chunk.</summary>
            <remarks>
            This method returns a text representation of the tag chunk. Labeled tags
            are returned in the form
            <code>label:tag</code>
            , and unlabeled tags are
            returned as just the tag name.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Tag">
            <summary>Get the tag for this chunk.</summary>
            <remarks>Get the tag for this chunk.</remarks>
            <returns>The tag for the chunk.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Label">
            <summary>Get the label, if any, assigned to this chunk.</summary>
            <remarks>Get the label, if any, assigned to this chunk.</remarks>
            <returns>
            The label assigned to this chunk, or
            <code>null</code>
            if no label is
            assigned to the chunk.
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.TextChunk">
            <summary>
            Represents a span of raw text (concrete syntax) between tags in a tree
            pattern string.
            </summary>
            <remarks>
            Represents a span of raw text (concrete syntax) between tags in a tree
            pattern string.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TextChunk.text">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TextChunk.Text"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TextChunk.#ctor(System.String)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TextChunk"/>
            with the specified text.
            </summary>
            <param name="text">The text of this chunk.</param>
            <exception>
            IllegalArgumentException
            if
            <code>text</code>
            is
            <code>null</code>
            .
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TextChunk.ToString">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TextChunk"/>
            returns the result of
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TextChunk.Text"/>
            in single quotes.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TextChunk.Text">
            <summary>Gets the raw text of this chunk.</summary>
            <remarks>Gets the raw text of this chunk.</remarks>
            <returns>The text of the chunk.</returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken">
            <summary>
            A
            <see cref="T:Antlr4.Runtime.IToken"/>
            object representing a token of a particular type; e.g.,
            <code>&lt;ID&gt;</code>
            . These tokens are created for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            chunks where the
            tag corresponds to a lexer rule or token type.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TokenTagToken.tokenName">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.TokenName"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TokenTagToken.label">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.Label"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TokenTagToken.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            for an unlabeled tag
            with the specified token name and type.
            </summary>
            <param name="tokenName">The token name.</param>
            <param name="type">The token type.</param>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TokenTagToken.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            with the specified
            token name, type, and label.
            </summary>
            <param name="tokenName">The token name.</param>
            <param name="type">The token type.</param>
            <param name="label">
            The label associated with the token tag, or
            <code>null</code>
            if
            the token tag is unlabeled.
            </param>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TokenTagToken.ToString">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            returns a string of the form
            <code>tokenName:type</code>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.TokenName">
            <summary>Gets the token name.</summary>
            <remarks>Gets the token name.</remarks>
            <returns>The token name.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.Label">
            <summary>Gets the label associated with the rule tag.</summary>
            <remarks>Gets the label associated with the rule tag.</remarks>
            <returns>
            The name of the label associated with the rule tag, or
            <code>null</code>
            if this is an unlabeled rule tag.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.Text">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            returns the token tag
            formatted with
            <code>&lt;</code>
            and
            <code>&gt;</code>
            delimiters.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Trees">
            <summary>A set of utility routines useful for all kinds of ANTLR trees.</summary>
            <remarks>A set of utility routines useful for all kinds of ANTLR trees.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree)">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)"/>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)"/>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree,System.Collections.Generic.IList{System.String})">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)"/>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.GetChildren(Antlr4.Runtime.Tree.ITree)">
            <summary>Return ordered list of all children of this node</summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.GetAncestors(Antlr4.Runtime.Tree.ITree)">
            <summary>Return a list of all ancestors of this node.</summary>
            <remarks>
            Return a list of all ancestors of this node.  The first node of
            list is the root and the last is the parent of this node.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Xpath.XPath">
            <summary>
            Represent a subset of XPath XML path syntax for use in identifying nodes in
            parse trees.
            </summary>
            <remarks>
            Represent a subset of XPath XML path syntax for use in identifying nodes in
            parse trees.
            <p>
            Split path into words and separators
            <code>/</code>
            and
            <code>//</code>
            via ANTLR
            itself then walk path elements from left to right. At each separator-word
            pair, find set of nodes. Next stage uses those as work list.</p>
            <p>
            The basic interface is
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.FindAll(Antlr4.Runtime.Tree.IParseTree,System.String,Antlr4.Runtime.Parser)">ParseTree.findAll</see>
            <code>(tree, pathString, parser)</code>
            .
            But that is just shorthand for:</p>
            <pre>
            <see cref="T:Antlr4.Runtime.Tree.Xpath.XPath"/>
            p = new
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.#ctor(Antlr4.Runtime.Parser,System.String)">XPath</see>
            (parser, pathString);
            return p.
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.Evaluate(Antlr4.Runtime.Tree.IParseTree)">evaluate</see>
            (tree);
            </pre>
            <p>
            See
            <code>org.antlr.v4.test.TestXPath</code>
            for descriptions. In short, this
            allows operators:</p>
            <dl>
            <dt>/</dt> <dd>root</dd>
            <dt>//</dt> <dd>anywhere</dd>
            <dt>!</dt> <dd>invert; this must appear directly after root or anywhere
            operator</dd>
            </dl>
            <p>
            and path elements:</p>
            <dl>
            <dt>ID</dt> <dd>token name</dd>
            <dt>'string'</dt> <dd>any string literal token from the grammar</dd>
            <dt>expr</dt> <dd>rule name</dd>
            <dt>*</dt> <dd>wildcard matching any node</dd>
            </dl>
            <p>
            Whitespace is not allowed.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPath.GetXPathElement(Antlr4.Runtime.IToken,System.Boolean)">
            <summary>
            Convert word like
            <code>*</code>
            or
            <code>ID</code>
            or
            <code>expr</code>
            to a path
            element.
            <code>anywhere</code>
            is
            <code>true</code>
            if
            <code>//</code>
            precedes the
            word.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPath.Evaluate(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Return a list of all nodes starting at
            <code>t</code>
            as root that satisfy the
            path. The root
            <code>/</code>
            is relative to the node passed to
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.Evaluate(Antlr4.Runtime.Tree.IParseTree)"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPathElement.#ctor(System.String)">
            <summary>
            Construct element like
            <code>/ID</code>
            or
            <code>ID</code>
            or
            <code>/*</code>
            etc...
            op is null if just node
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPathElement.Evaluate(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Given tree rooted at
            <code>t</code>
            return all nodes matched by this path
            element.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Xpath.XPathRuleAnywhereElement">
            <summary>
            Either
            <code>ID</code>
            at start of path or
            <code>...//ID</code>
            in middle of path.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.UnbufferedCharStream">
            <summary>Do not buffer up the entire char stream.</summary>
            <remarks>
            Do not buffer up the entire char stream. It does keep a small buffer
            for efficiency and also buffers while a mark exists (set by the
            lookahead prediction in parser). "Unbuffered" here refers to fact
            that it doesn't buffer all data, not that's it's on demand loading of char.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.data">
            <summary>A moving window buffer of the data being scanned.</summary>
            <remarks>
            A moving window buffer of the data being scanned. While there's a marker,
            we keep adding to buffer. Otherwise,
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Consume">consume()</see>
            resets so
            we start filling at index 0 again.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.n">
            <summary>
            The number of characters currently in
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            .
            <p>This is not the buffer capacity, that's
            <code>data.length</code>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.p">
            <summary>
            0..n-1 index into
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            of next character.
            <p>The
            <code>LA(1)</code>
            character is
            <code>data[p]</code>
            . If
            <code>p == n</code>
            , we are
            out of buffered characters.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.numMarkers">
            <summary>
            Count up with
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Mark">mark()</see>
            and down with
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Release(System.Int32)">release()</see>
            . When we
            <code>release()</code>
            the last mark,
            <code>numMarkers</code>
            reaches 0 and we reset the buffer. Copy
            <code>data[p]..data[n-1]</code>
            to
            <code>data[0]..data[(n-1)-p]</code>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.lastChar">
            <summary>
            This is the
            <code>LA(-1)</code>
            character for the current position.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.lastCharBufferStart">
            <summary>
            When
            <code>numMarkers &gt; 0</code>
            , this is the
            <code>LA(-1)</code>
            character for the
            first character in
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            . Otherwise, this is unspecified.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.currentCharIndex">
            <summary>Absolute character index.</summary>
            <remarks>
            Absolute character index. It's the index of the character about to be
            read via
            <code>LA(1)</code>
            . Goes from 0 to the number of characters in the
            entire stream, although the stream size is unknown before the end is
            reached.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.name">
            <summary>The name or source of this char stream.</summary>
            <remarks>The name or source of this char stream.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.#ctor">
            <summary>Useful for subclasses that pull char from other than this.input.</summary>
            <remarks>Useful for subclasses that pull char from other than this.input.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.#ctor(System.Int32)">
            <summary>Useful for subclasses that pull char from other than this.input.</summary>
            <remarks>Useful for subclasses that pull char from other than this.input.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Sync(System.Int32)">
            <summary>
            Make sure we have 'need' elements from current position
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.p">p</see>
            .
            Last valid
            <code>p</code>
            index is
            <code>data.length-1</code>
            .
            <code>p+need-1</code>
            is
            the char index 'need' elements ahead. If we need 1 element,
            <code>(p+1-1)==p</code>
            must be less than
            <code>data.length</code>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Fill(System.Int32)">
            <summary>
            Add
            <code>n</code>
            characters to the buffer. Returns the number of characters
            actually added to the buffer. If the return value is less than
            <code>n</code>
            ,
            then EOF was reached before
            <code>n</code>
            characters could be added.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.NextChar">
            <summary>
            Override to provide different source of characters than
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.input">input</see>
            .
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Mark">
            <summary>Return a marker that we can release later.</summary>
            <remarks>
            Return a marker that we can release later.
            <p>The specific marker value used for this class allows for some level of
            protection against misuse where
            <code>seek()</code>
            is called on a mark or
            <code>release()</code>
            is called in the wrong order.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Release(System.Int32)">
            <summary>Decrement number of markers, resetting buffer if we hit 0.</summary>
            <remarks>Decrement number of markers, resetting buffer if we hit 0.</remarks>
            <param name="marker"/>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Seek(System.Int32)">
            <summary>
            Seek to absolute character index, which might not be in the current
            sliding window.
            </summary>
            <remarks>
            Seek to absolute character index, which might not be in the current
            sliding window.  Move
            <code>p</code>
            to
            <code>index-bufferStartIndex</code>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">
            <summary>A moving window buffer of the data being scanned.</summary>
            <remarks>
            A moving window buffer of the data being scanned. While there's a marker,
            we keep adding to buffer. Otherwise,
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Consume">consume()</see>
            resets so
            we start filling at index 0 again.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.n">
            <summary>
            The number of tokens currently in
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">tokens</see>
            .
            <p>This is not the buffer capacity, that's
            <code>tokens.length</code>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.p">
            <summary>
            0..n-1 index into
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">tokens</see>
            of next token.
            <p>The
            <code>LT(1)</code>
            token is
            <code>tokens[p]</code>
            . If
            <code>p == n</code>
            , we are
            out of buffered tokens.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.numMarkers">
            <summary>
            Count up with
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Mark">mark()</see>
            and down with
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Release(System.Int32)">release()</see>
            . When we
            <code>release()</code>
            the last mark,
            <code>numMarkers</code>
            reaches 0 and we reset the buffer. Copy
            <code>tokens[p]..tokens[n-1]</code>
            to
            <code>tokens[0]..tokens[(n-1)-p]</code>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.lastToken">
            <summary>
            This is the
            <code>LT(-1)</code>
            token for the current position.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.lastTokenBufferStart">
            <summary>
            When
            <code>numMarkers &gt; 0</code>
            , this is the
            <code>LT(-1)</code>
            token for the
            first token in
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens"/>
            . Otherwise, this is
            <code>null</code>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.currentTokenIndex">
            <summary>Absolute token index.</summary>
            <remarks>
            Absolute token index. It's the index of the token about to be read via
            <code>LT(1)</code>
            . Goes from 0 to the number of tokens in the entire stream,
            although the stream size is unknown before the end is reached.
            <p>This value is used to set the token indexes if the stream provides tokens
            that implement
            <see cref="T:Antlr4.Runtime.IWritableToken"/>
            .</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Sync(System.Int32)">
            <summary>
            Make sure we have 'need' elements from current position
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.p">p</see>
            . Last valid
            <code>p</code>
            index is
            <code>tokens.length-1</code>
            .
            <code>p+need-1</code>
            is the tokens index 'need' elements
            ahead.  If we need 1 element,
            <code>(p+1-1)==p</code>
            must be less than
            <code>tokens.length</code>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Fill(System.Int32)">
            <summary>
            Add
            <code>n</code>
            elements to the buffer. Returns the number of tokens
            actually added to the buffer. If the return value is less than
            <code>n</code>
            ,
            then EOF was reached before
            <code>n</code>
            tokens could be added.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Mark">
            <summary>Return a marker that we can release later.</summary>
            <remarks>
            Return a marker that we can release later.
            <p>The specific marker value used for this class allows for some level of
            protection against misuse where
            <code>seek()</code>
            is called on a mark or
            <code>release()</code>
            is called in the wrong order.</p>
            </remarks>
        </member>
    </members>
</doc>
